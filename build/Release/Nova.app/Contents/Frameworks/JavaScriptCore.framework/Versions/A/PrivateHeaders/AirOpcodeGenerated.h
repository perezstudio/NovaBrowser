// Generated by opcode_generator.rb from JavaScriptCore/b3/air/AirOpcode.opcodes -- do not edit!
#pragma once
#include <wtf/Compiler.h>
WTF_ALLOW_UNSAFE_BUFFER_USAGE_BEGIN

#if ENABLE(B3_JIT)
#pragma push_macro("RotateLeft32")
#pragma push_macro("RotateLeft64")
#pragma push_macro("RotateRight32")
#pragma push_macro("RotateRight64")
#pragma push_macro("StoreFence")
#pragma push_macro("LoadFence")
#pragma push_macro("MemoryFence")
#undef RotateLeft32
#undef RotateLeft64
#undef RotateRight32
#undef RotateRight64
#undef StoreFence
#undef LoadFence
#undef MemoryFence
#include "AirInstInlines.h"
#include "B3ProcedureInlines.h"
#include "CCallHelpers.h"
#include "wtf/PrintStream.h"
namespace WTF {
using namespace JSC::B3::Air;
void printInternal(PrintStream& out, Opcode opcode)
{
    switch (opcode) {
    case Opcode::Nop:
        out.print("Nop");
        return;
    case Opcode::Add32:
        out.print("Add32");
        return;
    case Opcode::AddZeroExtend64:
        out.print("AddZeroExtend64");
        return;
    case Opcode::AddSignExtend64:
        out.print("AddSignExtend64");
        return;
    case Opcode::Add8:
        out.print("Add8");
        return;
    case Opcode::Add16:
        out.print("Add16");
        return;
    case Opcode::Add64:
        out.print("Add64");
        return;
    case Opcode::AddDouble:
        out.print("AddDouble");
        return;
    case Opcode::AddFloat:
        out.print("AddFloat");
        return;
    case Opcode::Sub32:
        out.print("Sub32");
        return;
    case Opcode::Sub64:
        out.print("Sub64");
        return;
    case Opcode::SubDouble:
        out.print("SubDouble");
        return;
    case Opcode::SubFloat:
        out.print("SubFloat");
        return;
    case Opcode::Neg32:
        out.print("Neg32");
        return;
    case Opcode::Neg64:
        out.print("Neg64");
        return;
    case Opcode::NegateDouble:
        out.print("NegateDouble");
        return;
    case Opcode::NegateFloat:
        out.print("NegateFloat");
        return;
    case Opcode::Mul32:
        out.print("Mul32");
        return;
    case Opcode::UMull32:
        out.print("UMull32");
        return;
    case Opcode::Mul64:
        out.print("Mul64");
        return;
    case Opcode::MultiplyAdd32:
        out.print("MultiplyAdd32");
        return;
    case Opcode::MultiplyAdd64:
        out.print("MultiplyAdd64");
        return;
    case Opcode::MultiplyAddSignExtend32:
        out.print("MultiplyAddSignExtend32");
        return;
    case Opcode::MultiplyAddZeroExtend32:
        out.print("MultiplyAddZeroExtend32");
        return;
    case Opcode::MultiplySub32:
        out.print("MultiplySub32");
        return;
    case Opcode::MultiplySub64:
        out.print("MultiplySub64");
        return;
    case Opcode::MultiplySubSignExtend32:
        out.print("MultiplySubSignExtend32");
        return;
    case Opcode::MultiplySubZeroExtend32:
        out.print("MultiplySubZeroExtend32");
        return;
    case Opcode::MultiplyNeg32:
        out.print("MultiplyNeg32");
        return;
    case Opcode::MultiplyNeg64:
        out.print("MultiplyNeg64");
        return;
    case Opcode::MultiplyNegSignExtend32:
        out.print("MultiplyNegSignExtend32");
        return;
    case Opcode::MultiplyNegZeroExtend32:
        out.print("MultiplyNegZeroExtend32");
        return;
    case Opcode::MultiplySignExtend32:
        out.print("MultiplySignExtend32");
        return;
    case Opcode::MultiplyZeroExtend32:
        out.print("MultiplyZeroExtend32");
        return;
    case Opcode::MulHigh32:
        out.print("MulHigh32");
        return;
    case Opcode::UMulHigh32:
        out.print("UMulHigh32");
        return;
    case Opcode::MulHigh64:
        out.print("MulHigh64");
        return;
    case Opcode::UMulHigh64:
        out.print("UMulHigh64");
        return;
    case Opcode::X86MulHigh32:
        out.print("X86MulHigh32");
        return;
    case Opcode::X86UMulHigh32:
        out.print("X86UMulHigh32");
        return;
    case Opcode::X86MulHigh64:
        out.print("X86MulHigh64");
        return;
    case Opcode::X86UMulHigh64:
        out.print("X86UMulHigh64");
        return;
    case Opcode::Div32:
        out.print("Div32");
        return;
    case Opcode::UDiv32:
        out.print("UDiv32");
        return;
    case Opcode::Div64:
        out.print("Div64");
        return;
    case Opcode::UDiv64:
        out.print("UDiv64");
        return;
    case Opcode::MulDouble:
        out.print("MulDouble");
        return;
    case Opcode::MulFloat:
        out.print("MulFloat");
        return;
    case Opcode::MultiplyNegDouble:
        out.print("MultiplyNegDouble");
        return;
    case Opcode::MultiplyNegFloat:
        out.print("MultiplyNegFloat");
        return;
    case Opcode::DivDouble:
        out.print("DivDouble");
        return;
    case Opcode::DivFloat:
        out.print("DivFloat");
        return;
    case Opcode::X86ConvertToDoubleWord32:
        out.print("X86ConvertToDoubleWord32");
        return;
    case Opcode::X86ConvertToQuadWord64:
        out.print("X86ConvertToQuadWord64");
        return;
    case Opcode::X86Div32:
        out.print("X86Div32");
        return;
    case Opcode::X86UDiv32:
        out.print("X86UDiv32");
        return;
    case Opcode::X86Div64:
        out.print("X86Div64");
        return;
    case Opcode::X86UDiv64:
        out.print("X86UDiv64");
        return;
    case Opcode::Lea32:
        out.print("Lea32");
        return;
    case Opcode::Lea64:
        out.print("Lea64");
        return;
    case Opcode::And32:
        out.print("And32");
        return;
    case Opcode::And64:
        out.print("And64");
        return;
    case Opcode::AndDouble:
        out.print("AndDouble");
        return;
    case Opcode::AndFloat:
        out.print("AndFloat");
        return;
    case Opcode::OrDouble:
        out.print("OrDouble");
        return;
    case Opcode::OrFloat:
        out.print("OrFloat");
        return;
    case Opcode::XorDouble:
        out.print("XorDouble");
        return;
    case Opcode::XorFloat:
        out.print("XorFloat");
        return;
    case Opcode::Lshift32:
        out.print("Lshift32");
        return;
    case Opcode::Lshift64:
        out.print("Lshift64");
        return;
    case Opcode::Rshift32:
        out.print("Rshift32");
        return;
    case Opcode::Rshift64:
        out.print("Rshift64");
        return;
    case Opcode::Urshift32:
        out.print("Urshift32");
        return;
    case Opcode::Urshift64:
        out.print("Urshift64");
        return;
    case Opcode::RotateRight32:
        out.print("RotateRight32");
        return;
    case Opcode::RotateRight64:
        out.print("RotateRight64");
        return;
    case Opcode::RotateLeft32:
        out.print("RotateLeft32");
        return;
    case Opcode::RotateLeft64:
        out.print("RotateLeft64");
        return;
    case Opcode::Or32:
        out.print("Or32");
        return;
    case Opcode::Or64:
        out.print("Or64");
        return;
    case Opcode::Xor32:
        out.print("Xor32");
        return;
    case Opcode::Xor64:
        out.print("Xor64");
        return;
    case Opcode::Not32:
        out.print("Not32");
        return;
    case Opcode::Not64:
        out.print("Not64");
        return;
    case Opcode::AbsDouble:
        out.print("AbsDouble");
        return;
    case Opcode::AbsFloat:
        out.print("AbsFloat");
        return;
    case Opcode::CeilDouble:
        out.print("CeilDouble");
        return;
    case Opcode::CeilFloat:
        out.print("CeilFloat");
        return;
    case Opcode::FloorDouble:
        out.print("FloorDouble");
        return;
    case Opcode::FloorFloat:
        out.print("FloorFloat");
        return;
    case Opcode::TruncDouble:
        out.print("TruncDouble");
        return;
    case Opcode::TruncFloat:
        out.print("TruncFloat");
        return;
    case Opcode::SqrtDouble:
        out.print("SqrtDouble");
        return;
    case Opcode::SqrtFloat:
        out.print("SqrtFloat");
        return;
    case Opcode::ConvertInt32ToDouble:
        out.print("ConvertInt32ToDouble");
        return;
    case Opcode::ConvertInt64ToDouble:
        out.print("ConvertInt64ToDouble");
        return;
    case Opcode::ConvertInt32ToFloat:
        out.print("ConvertInt32ToFloat");
        return;
    case Opcode::ConvertInt64ToFloat:
        out.print("ConvertInt64ToFloat");
        return;
    case Opcode::ConvertUInt32ToDouble:
        out.print("ConvertUInt32ToDouble");
        return;
    case Opcode::ConvertUInt32ToFloat:
        out.print("ConvertUInt32ToFloat");
        return;
    case Opcode::CountLeadingZeros32:
        out.print("CountLeadingZeros32");
        return;
    case Opcode::CountLeadingZeros64:
        out.print("CountLeadingZeros64");
        return;
    case Opcode::ConvertDoubleToFloat:
        out.print("ConvertDoubleToFloat");
        return;
    case Opcode::ConvertFloatToDouble:
        out.print("ConvertFloatToDouble");
        return;
    case Opcode::Move:
        out.print("Move");
        return;
    case Opcode::Swap32:
        out.print("Swap32");
        return;
    case Opcode::Swap64:
        out.print("Swap64");
        return;
    case Opcode::MoveWithIncrement64:
        out.print("MoveWithIncrement64");
        return;
    case Opcode::Move32:
        out.print("Move32");
        return;
    case Opcode::MoveWithIncrement32:
        out.print("MoveWithIncrement32");
        return;
    case Opcode::LoadPair32:
        out.print("LoadPair32");
        return;
    case Opcode::LoadPair64:
        out.print("LoadPair64");
        return;
    case Opcode::StorePair32:
        out.print("StorePair32");
        return;
    case Opcode::StorePair64:
        out.print("StorePair64");
        return;
    case Opcode::SignExtend8To64:
        out.print("SignExtend8To64");
        return;
    case Opcode::SignExtend16To64:
        out.print("SignExtend16To64");
        return;
    case Opcode::SignExtend32To64:
        out.print("SignExtend32To64");
        return;
    case Opcode::ZeroExtend8To32:
        out.print("ZeroExtend8To32");
        return;
    case Opcode::SignExtend8To32:
        out.print("SignExtend8To32");
        return;
    case Opcode::ZeroExtend16To32:
        out.print("ZeroExtend16To32");
        return;
    case Opcode::SignExtend16To32:
        out.print("SignExtend16To32");
        return;
    case Opcode::MoveFloat:
        out.print("MoveFloat");
        return;
    case Opcode::MoveDouble:
        out.print("MoveDouble");
        return;
    case Opcode::LoadPairFloat:
        out.print("LoadPairFloat");
        return;
    case Opcode::LoadPairDouble:
        out.print("LoadPairDouble");
        return;
    case Opcode::StorePairFloat:
        out.print("StorePairFloat");
        return;
    case Opcode::StorePairDouble:
        out.print("StorePairDouble");
        return;
    case Opcode::MoveVector:
        out.print("MoveVector");
        return;
    case Opcode::MoveZeroToDouble:
        out.print("MoveZeroToDouble");
        return;
    case Opcode::MoveZeroToFloat:
        out.print("MoveZeroToFloat");
        return;
    case Opcode::Move64ToDouble:
        out.print("Move64ToDouble");
        return;
    case Opcode::Move32ToDoubleHi:
        out.print("Move32ToDoubleHi");
        return;
    case Opcode::Move32ToFloat:
        out.print("Move32ToFloat");
        return;
    case Opcode::MoveDoubleTo64:
        out.print("MoveDoubleTo64");
        return;
    case Opcode::MoveDoubleHiTo32:
        out.print("MoveDoubleHiTo32");
        return;
    case Opcode::MoveFloatTo32:
        out.print("MoveFloatTo32");
        return;
    case Opcode::Load8:
        out.print("Load8");
        return;
    case Opcode::LoadAcq8:
        out.print("LoadAcq8");
        return;
    case Opcode::Store8:
        out.print("Store8");
        return;
    case Opcode::StoreRel8:
        out.print("StoreRel8");
        return;
    case Opcode::Load8SignedExtendTo32:
        out.print("Load8SignedExtendTo32");
        return;
    case Opcode::LoadAcq8SignedExtendTo32:
        out.print("LoadAcq8SignedExtendTo32");
        return;
    case Opcode::Load16:
        out.print("Load16");
        return;
    case Opcode::LoadAcq16:
        out.print("LoadAcq16");
        return;
    case Opcode::Load16SignedExtendTo32:
        out.print("Load16SignedExtendTo32");
        return;
    case Opcode::LoadAcq16SignedExtendTo32:
        out.print("LoadAcq16SignedExtendTo32");
        return;
    case Opcode::Store16:
        out.print("Store16");
        return;
    case Opcode::StoreRel16:
        out.print("StoreRel16");
        return;
    case Opcode::LoadAcq32:
        out.print("LoadAcq32");
        return;
    case Opcode::StoreRel32:
        out.print("StoreRel32");
        return;
    case Opcode::LoadAcq64:
        out.print("LoadAcq64");
        return;
    case Opcode::StoreRel64:
        out.print("StoreRel64");
        return;
    case Opcode::Xchg8:
        out.print("Xchg8");
        return;
    case Opcode::Xchg16:
        out.print("Xchg16");
        return;
    case Opcode::Xchg32:
        out.print("Xchg32");
        return;
    case Opcode::Xchg64:
        out.print("Xchg64");
        return;
    case Opcode::ExtractUnsignedBitfield32:
        out.print("ExtractUnsignedBitfield32");
        return;
    case Opcode::ExtractUnsignedBitfield64:
        out.print("ExtractUnsignedBitfield64");
        return;
    case Opcode::InsertUnsignedBitfieldInZero32:
        out.print("InsertUnsignedBitfieldInZero32");
        return;
    case Opcode::InsertUnsignedBitfieldInZero64:
        out.print("InsertUnsignedBitfieldInZero64");
        return;
    case Opcode::InsertBitField32:
        out.print("InsertBitField32");
        return;
    case Opcode::InsertBitField64:
        out.print("InsertBitField64");
        return;
    case Opcode::ClearBitField32:
        out.print("ClearBitField32");
        return;
    case Opcode::ClearBitField64:
        out.print("ClearBitField64");
        return;
    case Opcode::ClearBitsWithMask32:
        out.print("ClearBitsWithMask32");
        return;
    case Opcode::ClearBitsWithMask64:
        out.print("ClearBitsWithMask64");
        return;
    case Opcode::ReverseBits64:
        out.print("ReverseBits64");
        return;
    case Opcode::ReverseBits32:
        out.print("ReverseBits32");
        return;
    case Opcode::OrNot32:
        out.print("OrNot32");
        return;
    case Opcode::OrNot64:
        out.print("OrNot64");
        return;
    case Opcode::XorNot32:
        out.print("XorNot32");
        return;
    case Opcode::XorNot64:
        out.print("XorNot64");
        return;
    case Opcode::XorNotLeftShift32:
        out.print("XorNotLeftShift32");
        return;
    case Opcode::XorNotRightShift32:
        out.print("XorNotRightShift32");
        return;
    case Opcode::XorNotUnsignedRightShift32:
        out.print("XorNotUnsignedRightShift32");
        return;
    case Opcode::XorNotLeftShift64:
        out.print("XorNotLeftShift64");
        return;
    case Opcode::XorNotRightShift64:
        out.print("XorNotRightShift64");
        return;
    case Opcode::XorNotUnsignedRightShift64:
        out.print("XorNotUnsignedRightShift64");
        return;
    case Opcode::ExtractInsertBitfieldAtLowEnd32:
        out.print("ExtractInsertBitfieldAtLowEnd32");
        return;
    case Opcode::ExtractInsertBitfieldAtLowEnd64:
        out.print("ExtractInsertBitfieldAtLowEnd64");
        return;
    case Opcode::InsertSignedBitfieldInZero32:
        out.print("InsertSignedBitfieldInZero32");
        return;
    case Opcode::InsertSignedBitfieldInZero64:
        out.print("InsertSignedBitfieldInZero64");
        return;
    case Opcode::ExtractSignedBitfield32:
        out.print("ExtractSignedBitfield32");
        return;
    case Opcode::ExtractSignedBitfield64:
        out.print("ExtractSignedBitfield64");
        return;
    case Opcode::ExtractRegister32:
        out.print("ExtractRegister32");
        return;
    case Opcode::ExtractRegister64:
        out.print("ExtractRegister64");
        return;
    case Opcode::AddLeftShift32:
        out.print("AddLeftShift32");
        return;
    case Opcode::AddRightShift32:
        out.print("AddRightShift32");
        return;
    case Opcode::AddUnsignedRightShift32:
        out.print("AddUnsignedRightShift32");
        return;
    case Opcode::AddLeftShift64:
        out.print("AddLeftShift64");
        return;
    case Opcode::AddRightShift64:
        out.print("AddRightShift64");
        return;
    case Opcode::AddUnsignedRightShift64:
        out.print("AddUnsignedRightShift64");
        return;
    case Opcode::SubLeftShift32:
        out.print("SubLeftShift32");
        return;
    case Opcode::SubRightShift32:
        out.print("SubRightShift32");
        return;
    case Opcode::SubUnsignedRightShift32:
        out.print("SubUnsignedRightShift32");
        return;
    case Opcode::SubLeftShift64:
        out.print("SubLeftShift64");
        return;
    case Opcode::SubRightShift64:
        out.print("SubRightShift64");
        return;
    case Opcode::SubUnsignedRightShift64:
        out.print("SubUnsignedRightShift64");
        return;
    case Opcode::AndLeftShift32:
        out.print("AndLeftShift32");
        return;
    case Opcode::AndRightShift32:
        out.print("AndRightShift32");
        return;
    case Opcode::AndUnsignedRightShift32:
        out.print("AndUnsignedRightShift32");
        return;
    case Opcode::AndLeftShift64:
        out.print("AndLeftShift64");
        return;
    case Opcode::AndRightShift64:
        out.print("AndRightShift64");
        return;
    case Opcode::AndUnsignedRightShift64:
        out.print("AndUnsignedRightShift64");
        return;
    case Opcode::XorLeftShift32:
        out.print("XorLeftShift32");
        return;
    case Opcode::XorRightShift32:
        out.print("XorRightShift32");
        return;
    case Opcode::XorUnsignedRightShift32:
        out.print("XorUnsignedRightShift32");
        return;
    case Opcode::XorLeftShift64:
        out.print("XorLeftShift64");
        return;
    case Opcode::XorRightShift64:
        out.print("XorRightShift64");
        return;
    case Opcode::XorUnsignedRightShift64:
        out.print("XorUnsignedRightShift64");
        return;
    case Opcode::OrLeftShift32:
        out.print("OrLeftShift32");
        return;
    case Opcode::OrRightShift32:
        out.print("OrRightShift32");
        return;
    case Opcode::OrUnsignedRightShift32:
        out.print("OrUnsignedRightShift32");
        return;
    case Opcode::OrLeftShift64:
        out.print("OrLeftShift64");
        return;
    case Opcode::OrRightShift64:
        out.print("OrRightShift64");
        return;
    case Opcode::OrUnsignedRightShift64:
        out.print("OrUnsignedRightShift64");
        return;
    case Opcode::FloatMax:
        out.print("FloatMax");
        return;
    case Opcode::FloatMin:
        out.print("FloatMin");
        return;
    case Opcode::DoubleMax:
        out.print("DoubleMax");
        return;
    case Opcode::DoubleMin:
        out.print("DoubleMin");
        return;
    case Opcode::AtomicStrongCAS8:
        out.print("AtomicStrongCAS8");
        return;
    case Opcode::AtomicStrongCAS16:
        out.print("AtomicStrongCAS16");
        return;
    case Opcode::AtomicStrongCAS32:
        out.print("AtomicStrongCAS32");
        return;
    case Opcode::AtomicStrongCAS64:
        out.print("AtomicStrongCAS64");
        return;
    case Opcode::BranchAtomicStrongCAS8:
        out.print("BranchAtomicStrongCAS8");
        return;
    case Opcode::BranchAtomicStrongCAS16:
        out.print("BranchAtomicStrongCAS16");
        return;
    case Opcode::BranchAtomicStrongCAS32:
        out.print("BranchAtomicStrongCAS32");
        return;
    case Opcode::BranchAtomicStrongCAS64:
        out.print("BranchAtomicStrongCAS64");
        return;
    case Opcode::AtomicAdd8:
        out.print("AtomicAdd8");
        return;
    case Opcode::AtomicAdd16:
        out.print("AtomicAdd16");
        return;
    case Opcode::AtomicAdd32:
        out.print("AtomicAdd32");
        return;
    case Opcode::AtomicAdd64:
        out.print("AtomicAdd64");
        return;
    case Opcode::AtomicSub8:
        out.print("AtomicSub8");
        return;
    case Opcode::AtomicSub16:
        out.print("AtomicSub16");
        return;
    case Opcode::AtomicSub32:
        out.print("AtomicSub32");
        return;
    case Opcode::AtomicSub64:
        out.print("AtomicSub64");
        return;
    case Opcode::AtomicAnd8:
        out.print("AtomicAnd8");
        return;
    case Opcode::AtomicAnd16:
        out.print("AtomicAnd16");
        return;
    case Opcode::AtomicAnd32:
        out.print("AtomicAnd32");
        return;
    case Opcode::AtomicAnd64:
        out.print("AtomicAnd64");
        return;
    case Opcode::AtomicOr8:
        out.print("AtomicOr8");
        return;
    case Opcode::AtomicOr16:
        out.print("AtomicOr16");
        return;
    case Opcode::AtomicOr32:
        out.print("AtomicOr32");
        return;
    case Opcode::AtomicOr64:
        out.print("AtomicOr64");
        return;
    case Opcode::AtomicXor8:
        out.print("AtomicXor8");
        return;
    case Opcode::AtomicXor16:
        out.print("AtomicXor16");
        return;
    case Opcode::AtomicXor32:
        out.print("AtomicXor32");
        return;
    case Opcode::AtomicXor64:
        out.print("AtomicXor64");
        return;
    case Opcode::AtomicNeg8:
        out.print("AtomicNeg8");
        return;
    case Opcode::AtomicNeg16:
        out.print("AtomicNeg16");
        return;
    case Opcode::AtomicNeg32:
        out.print("AtomicNeg32");
        return;
    case Opcode::AtomicNeg64:
        out.print("AtomicNeg64");
        return;
    case Opcode::AtomicNot8:
        out.print("AtomicNot8");
        return;
    case Opcode::AtomicNot16:
        out.print("AtomicNot16");
        return;
    case Opcode::AtomicNot32:
        out.print("AtomicNot32");
        return;
    case Opcode::AtomicNot64:
        out.print("AtomicNot64");
        return;
    case Opcode::AtomicXchgAdd8:
        out.print("AtomicXchgAdd8");
        return;
    case Opcode::AtomicXchgAdd16:
        out.print("AtomicXchgAdd16");
        return;
    case Opcode::AtomicXchgAdd32:
        out.print("AtomicXchgAdd32");
        return;
    case Opcode::AtomicXchgAdd64:
        out.print("AtomicXchgAdd64");
        return;
    case Opcode::AtomicXchg8:
        out.print("AtomicXchg8");
        return;
    case Opcode::AtomicXchg16:
        out.print("AtomicXchg16");
        return;
    case Opcode::AtomicXchg32:
        out.print("AtomicXchg32");
        return;
    case Opcode::AtomicXchg64:
        out.print("AtomicXchg64");
        return;
    case Opcode::LoadLink8:
        out.print("LoadLink8");
        return;
    case Opcode::LoadLinkAcq8:
        out.print("LoadLinkAcq8");
        return;
    case Opcode::StoreCond8:
        out.print("StoreCond8");
        return;
    case Opcode::StoreCondRel8:
        out.print("StoreCondRel8");
        return;
    case Opcode::LoadLink16:
        out.print("LoadLink16");
        return;
    case Opcode::LoadLinkAcq16:
        out.print("LoadLinkAcq16");
        return;
    case Opcode::StoreCond16:
        out.print("StoreCond16");
        return;
    case Opcode::StoreCondRel16:
        out.print("StoreCondRel16");
        return;
    case Opcode::LoadLink32:
        out.print("LoadLink32");
        return;
    case Opcode::LoadLinkAcq32:
        out.print("LoadLinkAcq32");
        return;
    case Opcode::StoreCond32:
        out.print("StoreCond32");
        return;
    case Opcode::StoreCondRel32:
        out.print("StoreCondRel32");
        return;
    case Opcode::LoadLinkPair32:
        out.print("LoadLinkPair32");
        return;
    case Opcode::LoadLink64:
        out.print("LoadLink64");
        return;
    case Opcode::LoadLinkAcq64:
        out.print("LoadLinkAcq64");
        return;
    case Opcode::StoreCondPair32:
        out.print("StoreCondPair32");
        return;
    case Opcode::StoreCond64:
        out.print("StoreCond64");
        return;
    case Opcode::StoreCondRel64:
        out.print("StoreCondRel64");
        return;
    case Opcode::Depend32:
        out.print("Depend32");
        return;
    case Opcode::Depend64:
        out.print("Depend64");
        return;
    case Opcode::AtomicXchgOr8:
        out.print("AtomicXchgOr8");
        return;
    case Opcode::AtomicXchgOr16:
        out.print("AtomicXchgOr16");
        return;
    case Opcode::AtomicXchgOr32:
        out.print("AtomicXchgOr32");
        return;
    case Opcode::AtomicXchgOr64:
        out.print("AtomicXchgOr64");
        return;
    case Opcode::AtomicXchgClear8:
        out.print("AtomicXchgClear8");
        return;
    case Opcode::AtomicXchgClear16:
        out.print("AtomicXchgClear16");
        return;
    case Opcode::AtomicXchgClear32:
        out.print("AtomicXchgClear32");
        return;
    case Opcode::AtomicXchgClear64:
        out.print("AtomicXchgClear64");
        return;
    case Opcode::AtomicXchgXor8:
        out.print("AtomicXchgXor8");
        return;
    case Opcode::AtomicXchgXor16:
        out.print("AtomicXchgXor16");
        return;
    case Opcode::AtomicXchgXor32:
        out.print("AtomicXchgXor32");
        return;
    case Opcode::AtomicXchgXor64:
        out.print("AtomicXchgXor64");
        return;
    case Opcode::Compare32:
        out.print("Compare32");
        return;
    case Opcode::Compare64:
        out.print("Compare64");
        return;
    case Opcode::Test32:
        out.print("Test32");
        return;
    case Opcode::Test64:
        out.print("Test64");
        return;
    case Opcode::CompareDouble:
        out.print("CompareDouble");
        return;
    case Opcode::CompareFloat:
        out.print("CompareFloat");
        return;
    case Opcode::CompareDoubleWithZero:
        out.print("CompareDoubleWithZero");
        return;
    case Opcode::CompareFloatWithZero:
        out.print("CompareFloatWithZero");
        return;
    case Opcode::Branch8:
        out.print("Branch8");
        return;
    case Opcode::Branch32:
        out.print("Branch32");
        return;
    case Opcode::Branch64:
        out.print("Branch64");
        return;
    case Opcode::BranchTest8:
        out.print("BranchTest8");
        return;
    case Opcode::BranchTest32:
        out.print("BranchTest32");
        return;
    case Opcode::BranchTest64:
        out.print("BranchTest64");
        return;
    case Opcode::BranchTestBit64:
        out.print("BranchTestBit64");
        return;
    case Opcode::BranchTestBit32:
        out.print("BranchTestBit32");
        return;
    case Opcode::BranchDouble:
        out.print("BranchDouble");
        return;
    case Opcode::BranchFloat:
        out.print("BranchFloat");
        return;
    case Opcode::BranchDoubleWithZero:
        out.print("BranchDoubleWithZero");
        return;
    case Opcode::BranchFloatWithZero:
        out.print("BranchFloatWithZero");
        return;
    case Opcode::BranchAdd32:
        out.print("BranchAdd32");
        return;
    case Opcode::BranchAdd64:
        out.print("BranchAdd64");
        return;
    case Opcode::BranchMul32:
        out.print("BranchMul32");
        return;
    case Opcode::BranchMul64:
        out.print("BranchMul64");
        return;
    case Opcode::BranchSub32:
        out.print("BranchSub32");
        return;
    case Opcode::BranchSub64:
        out.print("BranchSub64");
        return;
    case Opcode::BranchNeg32:
        out.print("BranchNeg32");
        return;
    case Opcode::BranchNeg64:
        out.print("BranchNeg64");
        return;
    case Opcode::MoveConditionally32:
        out.print("MoveConditionally32");
        return;
    case Opcode::MoveConditionally64:
        out.print("MoveConditionally64");
        return;
    case Opcode::MoveConditionallyTest32:
        out.print("MoveConditionallyTest32");
        return;
    case Opcode::MoveConditionallyTest64:
        out.print("MoveConditionallyTest64");
        return;
    case Opcode::MoveConditionallyDouble:
        out.print("MoveConditionallyDouble");
        return;
    case Opcode::MoveConditionallyDoubleWithZero:
        out.print("MoveConditionallyDoubleWithZero");
        return;
    case Opcode::MoveConditionallyFloat:
        out.print("MoveConditionallyFloat");
        return;
    case Opcode::MoveConditionallyFloatWithZero:
        out.print("MoveConditionallyFloatWithZero");
        return;
    case Opcode::MoveDoubleConditionally32:
        out.print("MoveDoubleConditionally32");
        return;
    case Opcode::MoveDoubleConditionally64:
        out.print("MoveDoubleConditionally64");
        return;
    case Opcode::MoveDoubleConditionallyTest32:
        out.print("MoveDoubleConditionallyTest32");
        return;
    case Opcode::MoveDoubleConditionallyTest64:
        out.print("MoveDoubleConditionallyTest64");
        return;
    case Opcode::MoveDoubleConditionallyDouble:
        out.print("MoveDoubleConditionallyDouble");
        return;
    case Opcode::MoveDoubleConditionallyDoubleWithZero:
        out.print("MoveDoubleConditionallyDoubleWithZero");
        return;
    case Opcode::MoveDoubleConditionallyFloat:
        out.print("MoveDoubleConditionallyFloat");
        return;
    case Opcode::MoveDoubleConditionallyFloatWithZero:
        out.print("MoveDoubleConditionallyFloatWithZero");
        return;
    case Opcode::MemoryFence:
        out.print("MemoryFence");
        return;
    case Opcode::StoreFence:
        out.print("StoreFence");
        return;
    case Opcode::LoadFence:
        out.print("LoadFence");
        return;
    case Opcode::Jump:
        out.print("Jump");
        return;
    case Opcode::RetVoid:
        out.print("RetVoid");
        return;
    case Opcode::Ret32:
        out.print("Ret32");
        return;
    case Opcode::Ret64:
        out.print("Ret64");
        return;
    case Opcode::RetFloat:
        out.print("RetFloat");
        return;
    case Opcode::RetDouble:
        out.print("RetDouble");
        return;
    case Opcode::VectorReplaceLaneInt64:
        out.print("VectorReplaceLaneInt64");
        return;
    case Opcode::VectorReplaceLaneInt32:
        out.print("VectorReplaceLaneInt32");
        return;
    case Opcode::VectorReplaceLaneInt16:
        out.print("VectorReplaceLaneInt16");
        return;
    case Opcode::VectorReplaceLaneInt8:
        out.print("VectorReplaceLaneInt8");
        return;
    case Opcode::VectorReplaceLaneFloat64:
        out.print("VectorReplaceLaneFloat64");
        return;
    case Opcode::VectorReplaceLaneFloat32:
        out.print("VectorReplaceLaneFloat32");
        return;
    case Opcode::VectorExtractLaneInt64:
        out.print("VectorExtractLaneInt64");
        return;
    case Opcode::VectorExtractLaneInt32:
        out.print("VectorExtractLaneInt32");
        return;
    case Opcode::VectorExtractLaneSignedInt16:
        out.print("VectorExtractLaneSignedInt16");
        return;
    case Opcode::VectorExtractLaneUnsignedInt16:
        out.print("VectorExtractLaneUnsignedInt16");
        return;
    case Opcode::VectorExtractLaneSignedInt8:
        out.print("VectorExtractLaneSignedInt8");
        return;
    case Opcode::VectorExtractLaneUnsignedInt8:
        out.print("VectorExtractLaneUnsignedInt8");
        return;
    case Opcode::VectorExtractLaneFloat64:
        out.print("VectorExtractLaneFloat64");
        return;
    case Opcode::VectorExtractLaneFloat32:
        out.print("VectorExtractLaneFloat32");
        return;
    case Opcode::VectorSplatInt8:
        out.print("VectorSplatInt8");
        return;
    case Opcode::VectorSplatInt16:
        out.print("VectorSplatInt16");
        return;
    case Opcode::VectorSplatInt32:
        out.print("VectorSplatInt32");
        return;
    case Opcode::VectorSplatInt64:
        out.print("VectorSplatInt64");
        return;
    case Opcode::VectorSplatFloat32:
        out.print("VectorSplatFloat32");
        return;
    case Opcode::VectorSplatFloat64:
        out.print("VectorSplatFloat64");
        return;
    case Opcode::CompareFloatingPointVectorUnordered:
        out.print("CompareFloatingPointVectorUnordered");
        return;
    case Opcode::CompareFloatingPointVector:
        out.print("CompareFloatingPointVector");
        return;
    case Opcode::CompareIntegerVector:
        out.print("CompareIntegerVector");
        return;
    case Opcode::CompareIntegerVectorWithZero:
        out.print("CompareIntegerVectorWithZero");
        return;
    case Opcode::VectorUnsignedMax:
        out.print("VectorUnsignedMax");
        return;
    case Opcode::VectorUnsignedMin:
        out.print("VectorUnsignedMin");
        return;
    case Opcode::VectorAdd:
        out.print("VectorAdd");
        return;
    case Opcode::VectorSub:
        out.print("VectorSub");
        return;
    case Opcode::VectorAddSat:
        out.print("VectorAddSat");
        return;
    case Opcode::VectorSubSat:
        out.print("VectorSubSat");
        return;
    case Opcode::VectorMul:
        out.print("VectorMul");
        return;
    case Opcode::VectorMulByElementFloat32:
        out.print("VectorMulByElementFloat32");
        return;
    case Opcode::VectorMulByElementFloat64:
        out.print("VectorMulByElementFloat64");
        return;
    case Opcode::VectorDiv:
        out.print("VectorDiv");
        return;
    case Opcode::VectorMin:
        out.print("VectorMin");
        return;
    case Opcode::VectorMax:
        out.print("VectorMax");
        return;
    case Opcode::VectorPmin:
        out.print("VectorPmin");
        return;
    case Opcode::VectorPmax:
        out.print("VectorPmax");
        return;
    case Opcode::VectorNarrow:
        out.print("VectorNarrow");
        return;
    case Opcode::VectorBitwiseSelect:
        out.print("VectorBitwiseSelect");
        return;
    case Opcode::VectorNot:
        out.print("VectorNot");
        return;
    case Opcode::VectorAnd:
        out.print("VectorAnd");
        return;
    case Opcode::VectorAndnot:
        out.print("VectorAndnot");
        return;
    case Opcode::VectorOr:
        out.print("VectorOr");
        return;
    case Opcode::VectorXor:
        out.print("VectorXor");
        return;
    case Opcode::MoveZeroToVector:
        out.print("MoveZeroToVector");
        return;
    case Opcode::VectorUshl:
        out.print("VectorUshl");
        return;
    case Opcode::VectorSshr:
        out.print("VectorSshr");
        return;
    case Opcode::VectorUshr:
        out.print("VectorUshr");
        return;
    case Opcode::VectorSshl:
        out.print("VectorSshl");
        return;
    case Opcode::VectorUshl8:
        out.print("VectorUshl8");
        return;
    case Opcode::VectorUshr8:
        out.print("VectorUshr8");
        return;
    case Opcode::VectorSshr8:
        out.print("VectorSshr8");
        return;
    case Opcode::VectorHorizontalAdd:
        out.print("VectorHorizontalAdd");
        return;
    case Opcode::VectorZipUpper:
        out.print("VectorZipUpper");
        return;
    case Opcode::VectorUnzipEven:
        out.print("VectorUnzipEven");
        return;
    case Opcode::VectorExtractPair:
        out.print("VectorExtractPair");
        return;
    case Opcode::VectorAbs:
        out.print("VectorAbs");
        return;
    case Opcode::VectorAbsInt64:
        out.print("VectorAbsInt64");
        return;
    case Opcode::VectorNeg:
        out.print("VectorNeg");
        return;
    case Opcode::VectorPopcnt:
        out.print("VectorPopcnt");
        return;
    case Opcode::VectorCeil:
        out.print("VectorCeil");
        return;
    case Opcode::VectorFloor:
        out.print("VectorFloor");
        return;
    case Opcode::VectorTrunc:
        out.print("VectorTrunc");
        return;
    case Opcode::VectorTruncSat:
        out.print("VectorTruncSat");
        return;
    case Opcode::VectorTruncSatUnsignedFloat32:
        out.print("VectorTruncSatUnsignedFloat32");
        return;
    case Opcode::VectorTruncSatSignedFloat64:
        out.print("VectorTruncSatSignedFloat64");
        return;
    case Opcode::VectorTruncSatUnsignedFloat64:
        out.print("VectorTruncSatUnsignedFloat64");
        return;
    case Opcode::VectorConvert:
        out.print("VectorConvert");
        return;
    case Opcode::VectorConvertUnsigned:
        out.print("VectorConvertUnsigned");
        return;
    case Opcode::VectorConvertLow:
        out.print("VectorConvertLow");
        return;
    case Opcode::VectorConvertLowSignedInt32:
        out.print("VectorConvertLowSignedInt32");
        return;
    case Opcode::VectorConvertLowUnsignedInt32:
        out.print("VectorConvertLowUnsignedInt32");
        return;
    case Opcode::VectorNearest:
        out.print("VectorNearest");
        return;
    case Opcode::VectorSqrt:
        out.print("VectorSqrt");
        return;
    case Opcode::VectorExtendLow:
        out.print("VectorExtendLow");
        return;
    case Opcode::VectorExtendHigh:
        out.print("VectorExtendHigh");
        return;
    case Opcode::VectorPromote:
        out.print("VectorPromote");
        return;
    case Opcode::VectorDemote:
        out.print("VectorDemote");
        return;
    case Opcode::VectorLoad8Splat:
        out.print("VectorLoad8Splat");
        return;
    case Opcode::VectorLoad16Splat:
        out.print("VectorLoad16Splat");
        return;
    case Opcode::VectorLoad32Splat:
        out.print("VectorLoad32Splat");
        return;
    case Opcode::VectorLoad64Splat:
        out.print("VectorLoad64Splat");
        return;
    case Opcode::VectorLoad8Lane:
        out.print("VectorLoad8Lane");
        return;
    case Opcode::VectorLoad16Lane:
        out.print("VectorLoad16Lane");
        return;
    case Opcode::VectorLoad32Lane:
        out.print("VectorLoad32Lane");
        return;
    case Opcode::VectorLoad64Lane:
        out.print("VectorLoad64Lane");
        return;
    case Opcode::VectorStore8Lane:
        out.print("VectorStore8Lane");
        return;
    case Opcode::VectorStore16Lane:
        out.print("VectorStore16Lane");
        return;
    case Opcode::VectorStore32Lane:
        out.print("VectorStore32Lane");
        return;
    case Opcode::VectorStore64Lane:
        out.print("VectorStore64Lane");
        return;
    case Opcode::VectorAnyTrue:
        out.print("VectorAnyTrue");
        return;
    case Opcode::VectorAllTrue:
        out.print("VectorAllTrue");
        return;
    case Opcode::VectorBitmask:
        out.print("VectorBitmask");
        return;
    case Opcode::VectorExtaddPairwise:
        out.print("VectorExtaddPairwise");
        return;
    case Opcode::VectorExtaddPairwiseUnsignedInt16:
        out.print("VectorExtaddPairwiseUnsignedInt16");
        return;
    case Opcode::VectorAddPairwise:
        out.print("VectorAddPairwise");
        return;
    case Opcode::VectorAvgRound:
        out.print("VectorAvgRound");
        return;
    case Opcode::VectorMulHigh:
        out.print("VectorMulHigh");
        return;
    case Opcode::VectorMulLow:
        out.print("VectorMulLow");
        return;
    case Opcode::VectorMulSat:
        out.print("VectorMulSat");
        return;
    case Opcode::VectorDotProduct:
        out.print("VectorDotProduct");
        return;
    case Opcode::VectorSwizzle:
        out.print("VectorSwizzle");
        return;
    case Opcode::VectorSwizzle2:
        out.print("VectorSwizzle2");
        return;
    case Opcode::VectorFusedMulAdd:
        out.print("VectorFusedMulAdd");
        return;
    case Opcode::VectorFusedNegMulAdd:
        out.print("VectorFusedNegMulAdd");
        return;
    case Opcode::VectorDupElementInt8:
        out.print("VectorDupElementInt8");
        return;
    case Opcode::VectorDupElementInt16:
        out.print("VectorDupElementInt16");
        return;
    case Opcode::VectorDupElementInt32:
        out.print("VectorDupElementInt32");
        return;
    case Opcode::VectorDupElementInt64:
        out.print("VectorDupElementInt64");
        return;
    case Opcode::VectorDupElementFloat32:
        out.print("VectorDupElementFloat32");
        return;
    case Opcode::VectorDupElementFloat64:
        out.print("VectorDupElementFloat64");
        return;
    case Opcode::Oops:
        out.print("Oops");
        return;
    case Opcode::EntrySwitch:
        out.print("EntrySwitch");
        return;
    case Opcode::Shuffle:
        out.print("Shuffle");
        return;
    case Opcode::Patch:
        out.print("Patch");
        return;
    case Opcode::CCall:
        out.print("CCall");
        return;
    case Opcode::ColdCCall:
        out.print("ColdCCall");
        return;
    case Opcode::WasmBoundsCheck:
        out.print("WasmBoundsCheck");
        return;
    }
    RELEASE_ASSERT_NOT_REACHED();
}
} // namespace WTF
namespace JSC { namespace B3 { namespace Air {
const uint8_t g_formTable[9828] = {
// Nop 

// Invalid: Nop with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Nop with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Nop with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Nop with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Nop with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Nop with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add32 with numOperands = 0

// Invalid: Add32 with numOperands = 1
INVALID_INST_FORM, 
// Add32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Add32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Add32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddZeroExtend64 with numOperands = 0

// Invalid: AddZeroExtend64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AddZeroExtend64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// AddZeroExtend64 U:G:64, U:G:32, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: AddZeroExtend64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddZeroExtend64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddZeroExtend64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddSignExtend64 with numOperands = 0

// Invalid: AddSignExtend64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AddSignExtend64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// AddSignExtend64 U:G:64, U:G:32, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: AddSignExtend64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddSignExtend64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddSignExtend64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add8 with numOperands = 0

// Invalid: Add8 with numOperands = 1
INVALID_INST_FORM, 
// Add8 U:G:8, UD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: Add8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add16 with numOperands = 0

// Invalid: Add16 with numOperands = 1
INVALID_INST_FORM, 
// Add16 U:G:16, UD:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: Add16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add64 with numOperands = 0

// Invalid: Add64 with numOperands = 1
INVALID_INST_FORM, 
// Add64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Add64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: Add64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Add64 U:G:32, U:G:32, U:G:32, U:G:32, D:G:32, D:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width32), 
// Invalid: AddDouble with numOperands = 0

// Invalid: AddDouble with numOperands = 1
INVALID_INST_FORM, 
// AddDouble U:F:64, UD:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::UseDef, FP, Width64), 
// AddDouble U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: AddDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddFloat with numOperands = 0

// Invalid: AddFloat with numOperands = 1
INVALID_INST_FORM, 
// AddFloat U:F:32, UD:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::UseDef, FP, Width32), 
// AddFloat U:F:32, U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: AddFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Sub32 with numOperands = 0

// Invalid: Sub32 with numOperands = 1
INVALID_INST_FORM, 
// Sub32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Sub32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Sub32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Sub32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Sub32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Sub64 with numOperands = 0

// Invalid: Sub64 with numOperands = 1
INVALID_INST_FORM, 
// Sub64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Sub64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: Sub64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Sub64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Sub64 U:G:32, U:G:32, U:G:32, U:G:32, D:G:32, ED:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width32), ENCODE_INST_FORM(Arg::EarlyDef, GP, Width32), 
// Invalid: SubDouble with numOperands = 0

// Invalid: SubDouble with numOperands = 1
INVALID_INST_FORM, 
// SubDouble U:F:64, UD:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::UseDef, FP, Width64), 
// SubDouble U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: SubDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubFloat with numOperands = 0

// Invalid: SubFloat with numOperands = 1
INVALID_INST_FORM, 
// SubFloat U:F:32, UD:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::UseDef, FP, Width32), 
// SubFloat U:F:32, U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: SubFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Neg32 with numOperands = 0

// Neg32 UZD:G:32
ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Invalid: Neg32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Neg32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Neg32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Neg32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Neg32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Neg64 with numOperands = 0

// Neg64 UD:G:64
ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: Neg64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Neg64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Neg64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Neg64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Neg64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: NegateDouble with numOperands = 0

// Invalid: NegateDouble with numOperands = 1
INVALID_INST_FORM, 
// NegateDouble U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: NegateDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: NegateDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: NegateDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: NegateDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: NegateFloat with numOperands = 0

// Invalid: NegateFloat with numOperands = 1
INVALID_INST_FORM, 
// NegateFloat U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: NegateFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: NegateFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: NegateFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: NegateFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Mul32 with numOperands = 0

// Invalid: Mul32 with numOperands = 1
INVALID_INST_FORM, 
// Mul32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Mul32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Mul32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Mul32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Mul32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: UMull32 with numOperands = 0

// Invalid: UMull32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: UMull32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: UMull32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// UMull32 U:G:32, U:G:32, ZD:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: UMull32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: UMull32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Mul64 with numOperands = 0

// Invalid: Mul64 with numOperands = 1
INVALID_INST_FORM, 
// Mul64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Mul64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: Mul64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Mul64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Mul64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyAdd32 with numOperands = 0

// Invalid: MultiplyAdd32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MultiplyAdd32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyAdd32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MultiplyAdd32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: MultiplyAdd32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyAdd32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyAdd64 with numOperands = 0

// Invalid: MultiplyAdd64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MultiplyAdd64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyAdd64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MultiplyAdd64 U:G:64, U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: MultiplyAdd64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyAdd64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyAddSignExtend32 with numOperands = 0

// Invalid: MultiplyAddSignExtend32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MultiplyAddSignExtend32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyAddSignExtend32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MultiplyAddSignExtend32 U:G:32, U:G:32, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: MultiplyAddSignExtend32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyAddSignExtend32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyAddZeroExtend32 with numOperands = 0

// Invalid: MultiplyAddZeroExtend32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MultiplyAddZeroExtend32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyAddZeroExtend32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MultiplyAddZeroExtend32 U:G:32, U:G:32, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: MultiplyAddZeroExtend32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyAddZeroExtend32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplySub32 with numOperands = 0

// Invalid: MultiplySub32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MultiplySub32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplySub32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MultiplySub32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: MultiplySub32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplySub32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplySub64 with numOperands = 0

// Invalid: MultiplySub64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MultiplySub64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplySub64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MultiplySub64 U:G:64, U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: MultiplySub64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplySub64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplySubSignExtend32 with numOperands = 0

// Invalid: MultiplySubSignExtend32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MultiplySubSignExtend32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplySubSignExtend32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MultiplySubSignExtend32 U:G:32, U:G:32, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: MultiplySubSignExtend32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplySubSignExtend32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplySubZeroExtend32 with numOperands = 0

// Invalid: MultiplySubZeroExtend32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MultiplySubZeroExtend32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplySubZeroExtend32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MultiplySubZeroExtend32 U:G:32, U:G:32, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: MultiplySubZeroExtend32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplySubZeroExtend32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNeg32 with numOperands = 0

// Invalid: MultiplyNeg32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MultiplyNeg32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// MultiplyNeg32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: MultiplyNeg32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNeg32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNeg32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNeg64 with numOperands = 0

// Invalid: MultiplyNeg64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MultiplyNeg64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// MultiplyNeg64 U:G:64, U:G:64, ZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width64), 
// Invalid: MultiplyNeg64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNeg64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNeg64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNegSignExtend32 with numOperands = 0

// Invalid: MultiplyNegSignExtend32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MultiplyNegSignExtend32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// MultiplyNegSignExtend32 U:G:32, U:G:32, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: MultiplyNegSignExtend32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNegSignExtend32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNegSignExtend32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNegZeroExtend32 with numOperands = 0

// Invalid: MultiplyNegZeroExtend32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MultiplyNegZeroExtend32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// MultiplyNegZeroExtend32 U:G:32, U:G:32, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: MultiplyNegZeroExtend32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNegZeroExtend32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNegZeroExtend32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplySignExtend32 with numOperands = 0

// Invalid: MultiplySignExtend32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MultiplySignExtend32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// MultiplySignExtend32 U:G:32, U:G:32, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: MultiplySignExtend32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplySignExtend32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplySignExtend32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyZeroExtend32 with numOperands = 0

// Invalid: MultiplyZeroExtend32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MultiplyZeroExtend32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// MultiplyZeroExtend32 U:G:32, U:G:32, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: MultiplyZeroExtend32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyZeroExtend32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyZeroExtend32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MulHigh32 with numOperands = 0

// Invalid: MulHigh32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MulHigh32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// MulHigh32 U:G:32, U:G:32, D:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width32), 
// Invalid: MulHigh32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MulHigh32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MulHigh32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: UMulHigh32 with numOperands = 0

// Invalid: UMulHigh32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: UMulHigh32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// UMulHigh32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: UMulHigh32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: UMulHigh32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: UMulHigh32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MulHigh64 with numOperands = 0

// Invalid: MulHigh64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MulHigh64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// MulHigh64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: MulHigh64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MulHigh64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MulHigh64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: UMulHigh64 with numOperands = 0

// Invalid: UMulHigh64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: UMulHigh64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// UMulHigh64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: UMulHigh64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: UMulHigh64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: UMulHigh64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86MulHigh32 with numOperands = 0

// Invalid: X86MulHigh32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: X86MulHigh32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// X86MulHigh32 U:G:32, UD:G:32, D:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width32), 
// Invalid: X86MulHigh32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86MulHigh32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86MulHigh32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86UMulHigh32 with numOperands = 0

// Invalid: X86UMulHigh32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: X86UMulHigh32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// X86UMulHigh32 U:G:32, UD:G:32, D:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width32), 
// Invalid: X86UMulHigh32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86UMulHigh32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86UMulHigh32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86MulHigh64 with numOperands = 0

// Invalid: X86MulHigh64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: X86MulHigh64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// X86MulHigh64 U:G:64, UD:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: X86MulHigh64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86MulHigh64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86MulHigh64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86UMulHigh64 with numOperands = 0

// Invalid: X86UMulHigh64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: X86UMulHigh64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// X86UMulHigh64 U:G:64, UD:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: X86UMulHigh64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86UMulHigh64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86UMulHigh64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Div32 with numOperands = 0

// Invalid: Div32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Div32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Div32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Div32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Div32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Div32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: UDiv32 with numOperands = 0

// Invalid: UDiv32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: UDiv32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// UDiv32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: UDiv32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: UDiv32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: UDiv32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Div64 with numOperands = 0

// Invalid: Div64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Div64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Div64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: Div64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Div64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Div64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: UDiv64 with numOperands = 0

// Invalid: UDiv64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: UDiv64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// UDiv64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: UDiv64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: UDiv64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: UDiv64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MulDouble with numOperands = 0

// Invalid: MulDouble with numOperands = 1
INVALID_INST_FORM, 
// MulDouble U:F:64, UD:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::UseDef, FP, Width64), 
// MulDouble U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: MulDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MulDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MulDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MulFloat with numOperands = 0

// Invalid: MulFloat with numOperands = 1
INVALID_INST_FORM, 
// MulFloat U:F:32, UD:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::UseDef, FP, Width32), 
// MulFloat U:F:32, U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: MulFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MulFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MulFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNegDouble with numOperands = 0

// Invalid: MultiplyNegDouble with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MultiplyNegDouble with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// MultiplyNegDouble U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: MultiplyNegDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNegDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNegDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNegFloat with numOperands = 0

// Invalid: MultiplyNegFloat with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MultiplyNegFloat with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// MultiplyNegFloat U:F:32, U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: MultiplyNegFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNegFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNegFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: DivDouble with numOperands = 0

// Invalid: DivDouble with numOperands = 1
INVALID_INST_FORM, 
// DivDouble U:F:64, UD:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::UseDef, FP, Width64), 
// DivDouble U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: DivDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: DivDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: DivDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: DivFloat with numOperands = 0

// Invalid: DivFloat with numOperands = 1
INVALID_INST_FORM, 
// DivFloat U:F:32, UD:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::UseDef, FP, Width32), 
// DivFloat U:F:32, U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: DivFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: DivFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: DivFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86ConvertToDoubleWord32 with numOperands = 0

// Invalid: X86ConvertToDoubleWord32 with numOperands = 1
INVALID_INST_FORM, 
// X86ConvertToDoubleWord32 U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: X86ConvertToDoubleWord32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86ConvertToDoubleWord32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86ConvertToDoubleWord32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86ConvertToDoubleWord32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86ConvertToQuadWord64 with numOperands = 0

// Invalid: X86ConvertToQuadWord64 with numOperands = 1
INVALID_INST_FORM, 
// X86ConvertToQuadWord64 U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: X86ConvertToQuadWord64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86ConvertToQuadWord64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86ConvertToQuadWord64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86ConvertToQuadWord64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86Div32 with numOperands = 0

// Invalid: X86Div32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: X86Div32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// X86Div32 UZD:G:32, UZD:G:32, U:G:32
ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), 
// Invalid: X86Div32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86Div32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86Div32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86UDiv32 with numOperands = 0

// Invalid: X86UDiv32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: X86UDiv32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// X86UDiv32 UZD:G:32, UZD:G:32, U:G:32
ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), 
// Invalid: X86UDiv32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86UDiv32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86UDiv32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86Div64 with numOperands = 0

// Invalid: X86Div64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: X86Div64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// X86Div64 UZD:G:64, UZD:G:64, U:G:64
ENCODE_INST_FORM(Arg::UseZDef, GP, Width64), ENCODE_INST_FORM(Arg::UseZDef, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), 
// Invalid: X86Div64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86Div64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86Div64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86UDiv64 with numOperands = 0

// Invalid: X86UDiv64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: X86UDiv64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// X86UDiv64 UZD:G:64, UZD:G:64, U:G:64
ENCODE_INST_FORM(Arg::UseZDef, GP, Width64), ENCODE_INST_FORM(Arg::UseZDef, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), 
// Invalid: X86UDiv64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86UDiv64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86UDiv64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lea32 with numOperands = 0

// Invalid: Lea32 with numOperands = 1
INVALID_INST_FORM, 
// Lea32 UA:G:32, D:G:32
ENCODE_INST_FORM(Arg::UseAddr, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width32), 
// Invalid: Lea32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lea32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lea32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lea32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lea64 with numOperands = 0

// Invalid: Lea64 with numOperands = 1
INVALID_INST_FORM, 
// Lea64 UA:G:64, D:G:64
ENCODE_INST_FORM(Arg::UseAddr, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: Lea64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lea64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lea64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lea64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: And32 with numOperands = 0

// Invalid: And32 with numOperands = 1
INVALID_INST_FORM, 
// And32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// And32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: And32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: And32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: And32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: And64 with numOperands = 0

// Invalid: And64 with numOperands = 1
INVALID_INST_FORM, 
// And64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// And64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: And64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: And64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: And64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndDouble with numOperands = 0

// Invalid: AndDouble with numOperands = 1
INVALID_INST_FORM, 
// AndDouble U:F:64, UD:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::UseDef, FP, Width64), 
// AndDouble U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: AndDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndFloat with numOperands = 0

// Invalid: AndFloat with numOperands = 1
INVALID_INST_FORM, 
// AndFloat U:F:32, UD:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::UseDef, FP, Width32), 
// AndFloat U:F:32, U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: AndFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrDouble with numOperands = 0

// Invalid: OrDouble with numOperands = 1
INVALID_INST_FORM, 
// OrDouble U:F:64, UD:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::UseDef, FP, Width64), 
// OrDouble U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: OrDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrFloat with numOperands = 0

// Invalid: OrFloat with numOperands = 1
INVALID_INST_FORM, 
// OrFloat U:F:32, UD:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::UseDef, FP, Width32), 
// OrFloat U:F:32, U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: OrFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorDouble with numOperands = 0

// Invalid: XorDouble with numOperands = 1
INVALID_INST_FORM, 
// XorDouble U:F:64, UD:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::UseDef, FP, Width64), 
// XorDouble U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: XorDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorFloat with numOperands = 0

// Invalid: XorFloat with numOperands = 1
INVALID_INST_FORM, 
// XorFloat U:F:32, UD:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::UseDef, FP, Width32), 
// XorFloat U:F:32, U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: XorFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lshift32 with numOperands = 0

// Invalid: Lshift32 with numOperands = 1
INVALID_INST_FORM, 
// Lshift32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Lshift32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Lshift32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lshift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lshift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lshift64 with numOperands = 0

// Invalid: Lshift64 with numOperands = 1
INVALID_INST_FORM, 
// Lshift64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Lshift64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: Lshift64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lshift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lshift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Rshift32 with numOperands = 0

// Invalid: Rshift32 with numOperands = 1
INVALID_INST_FORM, 
// Rshift32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Rshift32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Rshift32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Rshift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Rshift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Rshift64 with numOperands = 0

// Invalid: Rshift64 with numOperands = 1
INVALID_INST_FORM, 
// Rshift64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Rshift64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: Rshift64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Rshift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Rshift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Urshift32 with numOperands = 0

// Invalid: Urshift32 with numOperands = 1
INVALID_INST_FORM, 
// Urshift32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Urshift32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Urshift32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Urshift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Urshift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Urshift64 with numOperands = 0

// Invalid: Urshift64 with numOperands = 1
INVALID_INST_FORM, 
// Urshift64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Urshift64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: Urshift64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Urshift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Urshift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateRight32 with numOperands = 0

// Invalid: RotateRight32 with numOperands = 1
INVALID_INST_FORM, 
// RotateRight32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// RotateRight32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: RotateRight32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateRight32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateRight32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateRight64 with numOperands = 0

// Invalid: RotateRight64 with numOperands = 1
INVALID_INST_FORM, 
// RotateRight64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// RotateRight64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: RotateRight64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateRight64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateRight64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateLeft32 with numOperands = 0

// Invalid: RotateLeft32 with numOperands = 1
INVALID_INST_FORM, 
// RotateLeft32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// RotateLeft32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: RotateLeft32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateLeft32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateLeft32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateLeft64 with numOperands = 0

// Invalid: RotateLeft64 with numOperands = 1
INVALID_INST_FORM, 
// RotateLeft64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: RotateLeft64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateLeft64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateLeft64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateLeft64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Or32 with numOperands = 0

// Invalid: Or32 with numOperands = 1
INVALID_INST_FORM, 
// Or32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Or32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Or32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Or32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Or32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Or64 with numOperands = 0

// Invalid: Or64 with numOperands = 1
INVALID_INST_FORM, 
// Or64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Or64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: Or64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Or64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Or64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xor32 with numOperands = 0

// Invalid: Xor32 with numOperands = 1
INVALID_INST_FORM, 
// Xor32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Xor32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Xor32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xor32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xor32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xor64 with numOperands = 0

// Invalid: Xor64 with numOperands = 1
INVALID_INST_FORM, 
// Xor64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Xor64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: Xor64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xor64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xor64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Not32 with numOperands = 0

// Not32 UZD:G:32
ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Not32 U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Not32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Not32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Not32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Not32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Not64 with numOperands = 0

// Not64 UD:G:64
ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Not64 U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: Not64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Not64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Not64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Not64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AbsDouble with numOperands = 0

// Invalid: AbsDouble with numOperands = 1
INVALID_INST_FORM, 
// AbsDouble U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: AbsDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AbsDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AbsDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AbsDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AbsFloat with numOperands = 0

// Invalid: AbsFloat with numOperands = 1
INVALID_INST_FORM, 
// AbsFloat U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: AbsFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AbsFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AbsFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AbsFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CeilDouble with numOperands = 0

// Invalid: CeilDouble with numOperands = 1
INVALID_INST_FORM, 
// CeilDouble U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: CeilDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CeilDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CeilDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CeilDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CeilFloat with numOperands = 0

// Invalid: CeilFloat with numOperands = 1
INVALID_INST_FORM, 
// CeilFloat U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: CeilFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CeilFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CeilFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CeilFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: FloorDouble with numOperands = 0

// Invalid: FloorDouble with numOperands = 1
INVALID_INST_FORM, 
// FloorDouble U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: FloorDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: FloorDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: FloorDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: FloorDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: FloorFloat with numOperands = 0

// Invalid: FloorFloat with numOperands = 1
INVALID_INST_FORM, 
// FloorFloat U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: FloorFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: FloorFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: FloorFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: FloorFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: TruncDouble with numOperands = 0

// Invalid: TruncDouble with numOperands = 1
INVALID_INST_FORM, 
// TruncDouble U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: TruncDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: TruncDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: TruncDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: TruncDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: TruncFloat with numOperands = 0

// Invalid: TruncFloat with numOperands = 1
INVALID_INST_FORM, 
// TruncFloat U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: TruncFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: TruncFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: TruncFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: TruncFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SqrtDouble with numOperands = 0

// Invalid: SqrtDouble with numOperands = 1
INVALID_INST_FORM, 
// SqrtDouble U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: SqrtDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SqrtDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SqrtDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SqrtDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SqrtFloat with numOperands = 0

// Invalid: SqrtFloat with numOperands = 1
INVALID_INST_FORM, 
// SqrtFloat U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: SqrtFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SqrtFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SqrtFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SqrtFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt32ToDouble with numOperands = 0

// Invalid: ConvertInt32ToDouble with numOperands = 1
INVALID_INST_FORM, 
// ConvertInt32ToDouble U:G:32, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: ConvertInt32ToDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt32ToDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt32ToDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt32ToDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt64ToDouble with numOperands = 0

// Invalid: ConvertInt64ToDouble with numOperands = 1
INVALID_INST_FORM, 
// ConvertInt64ToDouble U:G:64, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: ConvertInt64ToDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt64ToDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt64ToDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt64ToDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt32ToFloat with numOperands = 0

// Invalid: ConvertInt32ToFloat with numOperands = 1
INVALID_INST_FORM, 
// ConvertInt32ToFloat U:G:32, D:F:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: ConvertInt32ToFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt32ToFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt32ToFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt32ToFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt64ToFloat with numOperands = 0

// Invalid: ConvertInt64ToFloat with numOperands = 1
INVALID_INST_FORM, 
// ConvertInt64ToFloat U:G:64, D:F:32
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: ConvertInt64ToFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt64ToFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt64ToFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt64ToFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertUInt32ToDouble with numOperands = 0

// Invalid: ConvertUInt32ToDouble with numOperands = 1
INVALID_INST_FORM, 
// ConvertUInt32ToDouble U:G:32, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: ConvertUInt32ToDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertUInt32ToDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertUInt32ToDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertUInt32ToDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertUInt32ToFloat with numOperands = 0

// Invalid: ConvertUInt32ToFloat with numOperands = 1
INVALID_INST_FORM, 
// ConvertUInt32ToFloat U:G:32, D:F:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: ConvertUInt32ToFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertUInt32ToFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertUInt32ToFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertUInt32ToFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CountLeadingZeros32 with numOperands = 0

// Invalid: CountLeadingZeros32 with numOperands = 1
INVALID_INST_FORM, 
// CountLeadingZeros32 U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: CountLeadingZeros32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CountLeadingZeros32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CountLeadingZeros32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CountLeadingZeros32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CountLeadingZeros64 with numOperands = 0

// Invalid: CountLeadingZeros64 with numOperands = 1
INVALID_INST_FORM, 
// CountLeadingZeros64 U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: CountLeadingZeros64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CountLeadingZeros64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CountLeadingZeros64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CountLeadingZeros64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertDoubleToFloat with numOperands = 0

// Invalid: ConvertDoubleToFloat with numOperands = 1
INVALID_INST_FORM, 
// ConvertDoubleToFloat U:F:64, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: ConvertDoubleToFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertDoubleToFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertDoubleToFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertDoubleToFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertFloatToDouble with numOperands = 0

// Invalid: ConvertFloatToDouble with numOperands = 1
INVALID_INST_FORM, 
// ConvertFloatToDouble U:F:32, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: ConvertFloatToDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertFloatToDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertFloatToDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertFloatToDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move with numOperands = 0

// Invalid: Move with numOperands = 1
INVALID_INST_FORM, 
// Move U:G:Ptr, D:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Def, GP, pointerWidth()), 
// Move U:G:Ptr, D:G:Ptr, S:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Def, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Scratch, GP, pointerWidth()), 
// Invalid: Move with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Swap32 with numOperands = 0

// Invalid: Swap32 with numOperands = 1
INVALID_INST_FORM, 
// Swap32 UD:G:32, UD:G:32
ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: Swap32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Swap32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Swap32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Swap32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Swap64 with numOperands = 0

// Invalid: Swap64 with numOperands = 1
INVALID_INST_FORM, 
// Swap64 UD:G:64, UD:G:64
ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: Swap64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Swap64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Swap64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Swap64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveWithIncrement64 with numOperands = 0

// Invalid: MoveWithIncrement64 with numOperands = 1
INVALID_INST_FORM, 
// MoveWithIncrement64 UD:G:64, D:G:64
ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: MoveWithIncrement64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveWithIncrement64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveWithIncrement64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveWithIncrement64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move32 with numOperands = 0

// Invalid: Move32 with numOperands = 1
INVALID_INST_FORM, 
// Move32 U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Move32 U:G:32, ZD:G:32, S:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), ENCODE_INST_FORM(Arg::Scratch, GP, Width32), 
// Invalid: Move32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveWithIncrement32 with numOperands = 0

// Invalid: MoveWithIncrement32 with numOperands = 1
INVALID_INST_FORM, 
// MoveWithIncrement32 UD:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: MoveWithIncrement32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveWithIncrement32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveWithIncrement32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveWithIncrement32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadPair32 with numOperands = 0

// Invalid: LoadPair32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: LoadPair32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// LoadPair32 U:G:64, D:G:32, D:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width32), 
// Invalid: LoadPair32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadPair32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadPair32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadPair64 with numOperands = 0

// Invalid: LoadPair64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: LoadPair64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// LoadPair64 U:G:128, D:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width128), ENCODE_INST_FORM(Arg::Def, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: LoadPair64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadPair64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadPair64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StorePair32 with numOperands = 0

// Invalid: StorePair32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StorePair32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// StorePair32 U:G:32, U:G:32, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: StorePair32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StorePair32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StorePair32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StorePair64 with numOperands = 0

// Invalid: StorePair64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StorePair64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// StorePair64 U:G:64, U:G:64, D:G:128
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width128), 
// Invalid: StorePair64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StorePair64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StorePair64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend8To64 with numOperands = 0

// Invalid: SignExtend8To64 with numOperands = 1
INVALID_INST_FORM, 
// SignExtend8To64 U:G:8, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: SignExtend8To64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend8To64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend8To64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend8To64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend16To64 with numOperands = 0

// Invalid: SignExtend16To64 with numOperands = 1
INVALID_INST_FORM, 
// SignExtend16To64 U:G:16, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: SignExtend16To64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend16To64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend16To64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend16To64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend32To64 with numOperands = 0

// Invalid: SignExtend32To64 with numOperands = 1
INVALID_INST_FORM, 
// SignExtend32To64 U:G:32, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: SignExtend32To64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend32To64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend32To64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend32To64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ZeroExtend8To32 with numOperands = 0

// Invalid: ZeroExtend8To32 with numOperands = 1
INVALID_INST_FORM, 
// ZeroExtend8To32 U:G:8, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: ZeroExtend8To32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ZeroExtend8To32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ZeroExtend8To32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ZeroExtend8To32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend8To32 with numOperands = 0

// Invalid: SignExtend8To32 with numOperands = 1
INVALID_INST_FORM, 
// SignExtend8To32 U:G:8, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: SignExtend8To32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend8To32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend8To32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend8To32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ZeroExtend16To32 with numOperands = 0

// Invalid: ZeroExtend16To32 with numOperands = 1
INVALID_INST_FORM, 
// ZeroExtend16To32 U:G:16, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: ZeroExtend16To32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ZeroExtend16To32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ZeroExtend16To32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ZeroExtend16To32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend16To32 with numOperands = 0

// Invalid: SignExtend16To32 with numOperands = 1
INVALID_INST_FORM, 
// SignExtend16To32 U:G:16, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: SignExtend16To32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend16To32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend16To32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend16To32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveFloat with numOperands = 0

// Invalid: MoveFloat with numOperands = 1
INVALID_INST_FORM, 
// MoveFloat U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// MoveFloat U:F:32, D:F:32, S:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), ENCODE_INST_FORM(Arg::Scratch, FP, Width32), 
// Invalid: MoveFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDouble with numOperands = 0

// Invalid: MoveDouble with numOperands = 1
INVALID_INST_FORM, 
// MoveDouble U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// MoveDouble U:F:64, D:F:64, S:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), ENCODE_INST_FORM(Arg::Scratch, FP, Width64), 
// Invalid: MoveDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadPairFloat with numOperands = 0

// Invalid: LoadPairFloat with numOperands = 1
INVALID_INST_FORM, 
// Invalid: LoadPairFloat with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// LoadPairFloat U:F:64, D:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: LoadPairFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadPairFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadPairFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadPairDouble with numOperands = 0

// Invalid: LoadPairDouble with numOperands = 1
INVALID_INST_FORM, 
// Invalid: LoadPairDouble with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// LoadPairDouble U:F:128, D:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: LoadPairDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadPairDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadPairDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StorePairFloat with numOperands = 0

// Invalid: StorePairFloat with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StorePairFloat with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// StorePairFloat U:F:32, U:F:32, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: StorePairFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StorePairFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StorePairFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StorePairDouble with numOperands = 0

// Invalid: StorePairDouble with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StorePairDouble with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// StorePairDouble U:F:64, U:F:64, D:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: StorePairDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StorePairDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StorePairDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveVector with numOperands = 0

// Invalid: MoveVector with numOperands = 1
INVALID_INST_FORM, 
// MoveVector U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// MoveVector U:F:128, D:F:128, S:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: MoveVector with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveVector with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveVector with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveZeroToDouble with numOperands = 0

// MoveZeroToDouble D:F:64
ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: MoveZeroToDouble with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveZeroToDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveZeroToDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveZeroToDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveZeroToDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveZeroToFloat with numOperands = 0

// MoveZeroToFloat D:F:32
ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: MoveZeroToFloat with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveZeroToFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveZeroToFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveZeroToFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveZeroToFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move64ToDouble with numOperands = 0

// Invalid: Move64ToDouble with numOperands = 1
INVALID_INST_FORM, 
// Move64ToDouble U:G:64, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Move64ToDouble U:G:32, U:G:32, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: Move64ToDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move64ToDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move64ToDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move32ToDoubleHi with numOperands = 0

// Invalid: Move32ToDoubleHi with numOperands = 1
INVALID_INST_FORM, 
// Move32ToDoubleHi U:G:32, UD:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, FP, Width64), 
// Invalid: Move32ToDoubleHi with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move32ToDoubleHi with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move32ToDoubleHi with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move32ToDoubleHi with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move32ToFloat with numOperands = 0

// Invalid: Move32ToFloat with numOperands = 1
INVALID_INST_FORM, 
// Move32ToFloat U:G:32, D:F:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: Move32ToFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move32ToFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move32ToFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move32ToFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleTo64 with numOperands = 0

// Invalid: MoveDoubleTo64 with numOperands = 1
INVALID_INST_FORM, 
// MoveDoubleTo64 U:F:64, D:G:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// MoveDoubleTo64 U:F:64, D:G:32, D:G:32
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width32), 
// Invalid: MoveDoubleTo64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleTo64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleTo64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleHiTo32 with numOperands = 0

// Invalid: MoveDoubleHiTo32 with numOperands = 1
INVALID_INST_FORM, 
// MoveDoubleHiTo32 U:F:64, D:G:32
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width32), 
// Invalid: MoveDoubleHiTo32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleHiTo32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleHiTo32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleHiTo32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveFloatTo32 with numOperands = 0

// Invalid: MoveFloatTo32 with numOperands = 1
INVALID_INST_FORM, 
// MoveFloatTo32 U:F:32, D:G:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width32), 
// Invalid: MoveFloatTo32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveFloatTo32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveFloatTo32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveFloatTo32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load8 with numOperands = 0

// Invalid: Load8 with numOperands = 1
INVALID_INST_FORM, 
// Load8 U:G:8, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Load8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq8 with numOperands = 0

// Invalid: LoadAcq8 with numOperands = 1
INVALID_INST_FORM, 
// LoadAcq8 U:G:8, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: LoadAcq8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Store8 with numOperands = 0

// Invalid: Store8 with numOperands = 1
INVALID_INST_FORM, 
// Store8 U:G:8, D:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Def, GP, Width8), 
// Invalid: Store8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Store8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Store8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Store8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel8 with numOperands = 0

// Invalid: StoreRel8 with numOperands = 1
INVALID_INST_FORM, 
// StoreRel8 U:G:8, D:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Def, GP, Width8), 
// Invalid: StoreRel8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load8SignedExtendTo32 with numOperands = 0

// Invalid: Load8SignedExtendTo32 with numOperands = 1
INVALID_INST_FORM, 
// Load8SignedExtendTo32 U:G:8, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Load8SignedExtendTo32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load8SignedExtendTo32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load8SignedExtendTo32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load8SignedExtendTo32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq8SignedExtendTo32 with numOperands = 0

// Invalid: LoadAcq8SignedExtendTo32 with numOperands = 1
INVALID_INST_FORM, 
// LoadAcq8SignedExtendTo32 U:G:8, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: LoadAcq8SignedExtendTo32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq8SignedExtendTo32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq8SignedExtendTo32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq8SignedExtendTo32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load16 with numOperands = 0

// Invalid: Load16 with numOperands = 1
INVALID_INST_FORM, 
// Load16 U:G:16, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Load16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq16 with numOperands = 0

// Invalid: LoadAcq16 with numOperands = 1
INVALID_INST_FORM, 
// LoadAcq16 U:G:16, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: LoadAcq16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load16SignedExtendTo32 with numOperands = 0

// Invalid: Load16SignedExtendTo32 with numOperands = 1
INVALID_INST_FORM, 
// Load16SignedExtendTo32 U:G:16, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Load16SignedExtendTo32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load16SignedExtendTo32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load16SignedExtendTo32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load16SignedExtendTo32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq16SignedExtendTo32 with numOperands = 0

// Invalid: LoadAcq16SignedExtendTo32 with numOperands = 1
INVALID_INST_FORM, 
// LoadAcq16SignedExtendTo32 U:G:16, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: LoadAcq16SignedExtendTo32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq16SignedExtendTo32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq16SignedExtendTo32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq16SignedExtendTo32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Store16 with numOperands = 0

// Invalid: Store16 with numOperands = 1
INVALID_INST_FORM, 
// Store16 U:G:16, D:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::Def, GP, Width16), 
// Invalid: Store16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Store16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Store16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Store16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel16 with numOperands = 0

// Invalid: StoreRel16 with numOperands = 1
INVALID_INST_FORM, 
// StoreRel16 U:G:16, D:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::Def, GP, Width16), 
// Invalid: StoreRel16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq32 with numOperands = 0

// Invalid: LoadAcq32 with numOperands = 1
INVALID_INST_FORM, 
// LoadAcq32 U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: LoadAcq32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel32 with numOperands = 0

// Invalid: StoreRel32 with numOperands = 1
INVALID_INST_FORM, 
// StoreRel32 U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: StoreRel32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq64 with numOperands = 0

// Invalid: LoadAcq64 with numOperands = 1
INVALID_INST_FORM, 
// LoadAcq64 U:G:64, ZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width64), 
// Invalid: LoadAcq64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel64 with numOperands = 0

// Invalid: StoreRel64 with numOperands = 1
INVALID_INST_FORM, 
// StoreRel64 U:G:64, ZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width64), 
// Invalid: StoreRel64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg8 with numOperands = 0

// Invalid: Xchg8 with numOperands = 1
INVALID_INST_FORM, 
// Xchg8 UD:G:8, UD:G:8
ENCODE_INST_FORM(Arg::UseDef, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: Xchg8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg16 with numOperands = 0

// Invalid: Xchg16 with numOperands = 1
INVALID_INST_FORM, 
// Xchg16 UD:G:16, UD:G:16
ENCODE_INST_FORM(Arg::UseDef, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: Xchg16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg32 with numOperands = 0

// Invalid: Xchg32 with numOperands = 1
INVALID_INST_FORM, 
// Xchg32 UD:G:32, UD:G:32
ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: Xchg32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg64 with numOperands = 0

// Invalid: Xchg64 with numOperands = 1
INVALID_INST_FORM, 
// Xchg64 UD:G:64, UD:G:64
ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: Xchg64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractUnsignedBitfield32 with numOperands = 0

// Invalid: ExtractUnsignedBitfield32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: ExtractUnsignedBitfield32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractUnsignedBitfield32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// ExtractUnsignedBitfield32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: ExtractUnsignedBitfield32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractUnsignedBitfield32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractUnsignedBitfield64 with numOperands = 0

// Invalid: ExtractUnsignedBitfield64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: ExtractUnsignedBitfield64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractUnsignedBitfield64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// ExtractUnsignedBitfield64 U:G:64, U:G:32, U:G:32, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: ExtractUnsignedBitfield64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractUnsignedBitfield64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: InsertUnsignedBitfieldInZero32 with numOperands = 0

// Invalid: InsertUnsignedBitfieldInZero32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: InsertUnsignedBitfieldInZero32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: InsertUnsignedBitfieldInZero32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// InsertUnsignedBitfieldInZero32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: InsertUnsignedBitfieldInZero32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: InsertUnsignedBitfieldInZero32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: InsertUnsignedBitfieldInZero64 with numOperands = 0

// Invalid: InsertUnsignedBitfieldInZero64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: InsertUnsignedBitfieldInZero64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: InsertUnsignedBitfieldInZero64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// InsertUnsignedBitfieldInZero64 U:G:64, U:G:32, U:G:32, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: InsertUnsignedBitfieldInZero64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: InsertUnsignedBitfieldInZero64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: InsertBitField32 with numOperands = 0

// Invalid: InsertBitField32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: InsertBitField32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: InsertBitField32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// InsertBitField32 U:G:32, U:G:32, U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Invalid: InsertBitField32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: InsertBitField32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: InsertBitField64 with numOperands = 0

// Invalid: InsertBitField64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: InsertBitField64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: InsertBitField64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// InsertBitField64 U:G:64, U:G:32, U:G:32, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: InsertBitField64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: InsertBitField64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ClearBitField32 with numOperands = 0

// Invalid: ClearBitField32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: ClearBitField32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// ClearBitField32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: ClearBitField32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ClearBitField32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ClearBitField32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ClearBitField64 with numOperands = 0

// Invalid: ClearBitField64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: ClearBitField64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// ClearBitField64 U:G:32, U:G:32, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: ClearBitField64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ClearBitField64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ClearBitField64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ClearBitsWithMask32 with numOperands = 0

// Invalid: ClearBitsWithMask32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: ClearBitsWithMask32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// ClearBitsWithMask32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: ClearBitsWithMask32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ClearBitsWithMask32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ClearBitsWithMask32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ClearBitsWithMask64 with numOperands = 0

// Invalid: ClearBitsWithMask64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: ClearBitsWithMask64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// ClearBitsWithMask64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: ClearBitsWithMask64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ClearBitsWithMask64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ClearBitsWithMask64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ReverseBits64 with numOperands = 0

// Invalid: ReverseBits64 with numOperands = 1
INVALID_INST_FORM, 
// ReverseBits64 U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: ReverseBits64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ReverseBits64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ReverseBits64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ReverseBits64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ReverseBits32 with numOperands = 0

// Invalid: ReverseBits32 with numOperands = 1
INVALID_INST_FORM, 
// ReverseBits32 U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: ReverseBits32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ReverseBits32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ReverseBits32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ReverseBits32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrNot32 with numOperands = 0

// Invalid: OrNot32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: OrNot32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// OrNot32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: OrNot32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrNot32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrNot32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrNot64 with numOperands = 0

// Invalid: OrNot64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: OrNot64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// OrNot64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: OrNot64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrNot64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrNot64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNot32 with numOperands = 0

// Invalid: XorNot32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: XorNot32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// XorNot32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: XorNot32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNot32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNot32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNot64 with numOperands = 0

// Invalid: XorNot64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: XorNot64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// XorNot64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: XorNot64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNot64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNot64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNotLeftShift32 with numOperands = 0

// Invalid: XorNotLeftShift32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: XorNotLeftShift32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNotLeftShift32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// XorNotLeftShift32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: XorNotLeftShift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNotLeftShift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNotRightShift32 with numOperands = 0

// Invalid: XorNotRightShift32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: XorNotRightShift32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNotRightShift32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// XorNotRightShift32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: XorNotRightShift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNotRightShift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNotUnsignedRightShift32 with numOperands = 0

// Invalid: XorNotUnsignedRightShift32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: XorNotUnsignedRightShift32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNotUnsignedRightShift32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// XorNotUnsignedRightShift32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: XorNotUnsignedRightShift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNotUnsignedRightShift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNotLeftShift64 with numOperands = 0

// Invalid: XorNotLeftShift64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: XorNotLeftShift64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNotLeftShift64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// XorNotLeftShift64 U:G:64, U:G:64, U:G:32, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: XorNotLeftShift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNotLeftShift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNotRightShift64 with numOperands = 0

// Invalid: XorNotRightShift64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: XorNotRightShift64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNotRightShift64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// XorNotRightShift64 U:G:64, U:G:64, U:G:32, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: XorNotRightShift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNotRightShift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNotUnsignedRightShift64 with numOperands = 0

// Invalid: XorNotUnsignedRightShift64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: XorNotUnsignedRightShift64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNotUnsignedRightShift64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// XorNotUnsignedRightShift64 U:G:64, U:G:64, U:G:32, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: XorNotUnsignedRightShift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorNotUnsignedRightShift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractInsertBitfieldAtLowEnd32 with numOperands = 0

// Invalid: ExtractInsertBitfieldAtLowEnd32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: ExtractInsertBitfieldAtLowEnd32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractInsertBitfieldAtLowEnd32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// ExtractInsertBitfieldAtLowEnd32 U:G:32, U:G:32, U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Invalid: ExtractInsertBitfieldAtLowEnd32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractInsertBitfieldAtLowEnd32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractInsertBitfieldAtLowEnd64 with numOperands = 0

// Invalid: ExtractInsertBitfieldAtLowEnd64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: ExtractInsertBitfieldAtLowEnd64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractInsertBitfieldAtLowEnd64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// ExtractInsertBitfieldAtLowEnd64 U:G:64, U:G:32, U:G:32, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: ExtractInsertBitfieldAtLowEnd64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractInsertBitfieldAtLowEnd64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: InsertSignedBitfieldInZero32 with numOperands = 0

// Invalid: InsertSignedBitfieldInZero32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: InsertSignedBitfieldInZero32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: InsertSignedBitfieldInZero32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// InsertSignedBitfieldInZero32 U:G:32, U:G:32, U:G:32, D:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width32), 
// Invalid: InsertSignedBitfieldInZero32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: InsertSignedBitfieldInZero32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: InsertSignedBitfieldInZero64 with numOperands = 0

// Invalid: InsertSignedBitfieldInZero64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: InsertSignedBitfieldInZero64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: InsertSignedBitfieldInZero64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// InsertSignedBitfieldInZero64 U:G:64, U:G:32, U:G:32, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: InsertSignedBitfieldInZero64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: InsertSignedBitfieldInZero64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractSignedBitfield32 with numOperands = 0

// Invalid: ExtractSignedBitfield32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: ExtractSignedBitfield32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractSignedBitfield32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// ExtractSignedBitfield32 U:G:32, U:G:32, U:G:32, D:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width32), 
// Invalid: ExtractSignedBitfield32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractSignedBitfield32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractSignedBitfield64 with numOperands = 0

// Invalid: ExtractSignedBitfield64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: ExtractSignedBitfield64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractSignedBitfield64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// ExtractSignedBitfield64 U:G:64, U:G:32, U:G:32, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: ExtractSignedBitfield64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractSignedBitfield64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractRegister32 with numOperands = 0

// Invalid: ExtractRegister32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: ExtractRegister32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractRegister32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// ExtractRegister32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: ExtractRegister32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractRegister32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractRegister64 with numOperands = 0

// Invalid: ExtractRegister64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: ExtractRegister64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractRegister64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// ExtractRegister64 U:G:64, U:G:32, U:G:32, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: ExtractRegister64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ExtractRegister64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddLeftShift32 with numOperands = 0

// Invalid: AddLeftShift32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AddLeftShift32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddLeftShift32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// AddLeftShift32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: AddLeftShift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddLeftShift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddRightShift32 with numOperands = 0

// Invalid: AddRightShift32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AddRightShift32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddRightShift32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// AddRightShift32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: AddRightShift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddRightShift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddUnsignedRightShift32 with numOperands = 0

// Invalid: AddUnsignedRightShift32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AddUnsignedRightShift32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddUnsignedRightShift32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// AddUnsignedRightShift32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: AddUnsignedRightShift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddUnsignedRightShift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddLeftShift64 with numOperands = 0

// Invalid: AddLeftShift64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AddLeftShift64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddLeftShift64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// AddLeftShift64 U:G:64, U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: AddLeftShift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddLeftShift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddRightShift64 with numOperands = 0

// Invalid: AddRightShift64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AddRightShift64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddRightShift64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// AddRightShift64 U:G:64, U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: AddRightShift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddRightShift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddUnsignedRightShift64 with numOperands = 0

// Invalid: AddUnsignedRightShift64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AddUnsignedRightShift64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddUnsignedRightShift64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// AddUnsignedRightShift64 U:G:64, U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: AddUnsignedRightShift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddUnsignedRightShift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubLeftShift32 with numOperands = 0

// Invalid: SubLeftShift32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: SubLeftShift32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubLeftShift32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// SubLeftShift32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: SubLeftShift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubLeftShift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubRightShift32 with numOperands = 0

// Invalid: SubRightShift32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: SubRightShift32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubRightShift32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// SubRightShift32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: SubRightShift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubRightShift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubUnsignedRightShift32 with numOperands = 0

// Invalid: SubUnsignedRightShift32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: SubUnsignedRightShift32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubUnsignedRightShift32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// SubUnsignedRightShift32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: SubUnsignedRightShift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubUnsignedRightShift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubLeftShift64 with numOperands = 0

// Invalid: SubLeftShift64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: SubLeftShift64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubLeftShift64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// SubLeftShift64 U:G:64, U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: SubLeftShift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubLeftShift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubRightShift64 with numOperands = 0

// Invalid: SubRightShift64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: SubRightShift64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubRightShift64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// SubRightShift64 U:G:64, U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: SubRightShift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubRightShift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubUnsignedRightShift64 with numOperands = 0

// Invalid: SubUnsignedRightShift64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: SubUnsignedRightShift64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubUnsignedRightShift64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// SubUnsignedRightShift64 U:G:64, U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: SubUnsignedRightShift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubUnsignedRightShift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndLeftShift32 with numOperands = 0

// Invalid: AndLeftShift32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AndLeftShift32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndLeftShift32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// AndLeftShift32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: AndLeftShift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndLeftShift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndRightShift32 with numOperands = 0

// Invalid: AndRightShift32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AndRightShift32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndRightShift32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// AndRightShift32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: AndRightShift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndRightShift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndUnsignedRightShift32 with numOperands = 0

// Invalid: AndUnsignedRightShift32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AndUnsignedRightShift32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndUnsignedRightShift32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// AndUnsignedRightShift32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: AndUnsignedRightShift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndUnsignedRightShift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndLeftShift64 with numOperands = 0

// Invalid: AndLeftShift64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AndLeftShift64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndLeftShift64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// AndLeftShift64 U:G:64, U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: AndLeftShift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndLeftShift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndRightShift64 with numOperands = 0

// Invalid: AndRightShift64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AndRightShift64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndRightShift64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// AndRightShift64 U:G:64, U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: AndRightShift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndRightShift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndUnsignedRightShift64 with numOperands = 0

// Invalid: AndUnsignedRightShift64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AndUnsignedRightShift64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndUnsignedRightShift64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// AndUnsignedRightShift64 U:G:64, U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: AndUnsignedRightShift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndUnsignedRightShift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorLeftShift32 with numOperands = 0

// Invalid: XorLeftShift32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: XorLeftShift32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorLeftShift32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// XorLeftShift32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: XorLeftShift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorLeftShift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorRightShift32 with numOperands = 0

// Invalid: XorRightShift32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: XorRightShift32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorRightShift32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// XorRightShift32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: XorRightShift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorRightShift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorUnsignedRightShift32 with numOperands = 0

// Invalid: XorUnsignedRightShift32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: XorUnsignedRightShift32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorUnsignedRightShift32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// XorUnsignedRightShift32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: XorUnsignedRightShift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorUnsignedRightShift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorLeftShift64 with numOperands = 0

// Invalid: XorLeftShift64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: XorLeftShift64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorLeftShift64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// XorLeftShift64 U:G:64, U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: XorLeftShift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorLeftShift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorRightShift64 with numOperands = 0

// Invalid: XorRightShift64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: XorRightShift64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorRightShift64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// XorRightShift64 U:G:64, U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: XorRightShift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorRightShift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorUnsignedRightShift64 with numOperands = 0

// Invalid: XorUnsignedRightShift64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: XorUnsignedRightShift64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorUnsignedRightShift64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// XorUnsignedRightShift64 U:G:64, U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: XorUnsignedRightShift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorUnsignedRightShift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrLeftShift32 with numOperands = 0

// Invalid: OrLeftShift32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: OrLeftShift32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrLeftShift32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// OrLeftShift32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: OrLeftShift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrLeftShift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrRightShift32 with numOperands = 0

// Invalid: OrRightShift32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: OrRightShift32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrRightShift32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// OrRightShift32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: OrRightShift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrRightShift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrUnsignedRightShift32 with numOperands = 0

// Invalid: OrUnsignedRightShift32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: OrUnsignedRightShift32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrUnsignedRightShift32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// OrUnsignedRightShift32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: OrUnsignedRightShift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrUnsignedRightShift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrLeftShift64 with numOperands = 0

// Invalid: OrLeftShift64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: OrLeftShift64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrLeftShift64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// OrLeftShift64 U:G:64, U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: OrLeftShift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrLeftShift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrRightShift64 with numOperands = 0

// Invalid: OrRightShift64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: OrRightShift64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrRightShift64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// OrRightShift64 U:G:64, U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: OrRightShift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrRightShift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrUnsignedRightShift64 with numOperands = 0

// Invalid: OrUnsignedRightShift64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: OrUnsignedRightShift64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrUnsignedRightShift64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// OrUnsignedRightShift64 U:G:64, U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: OrUnsignedRightShift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrUnsignedRightShift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: FloatMax with numOperands = 0

// Invalid: FloatMax with numOperands = 1
INVALID_INST_FORM, 
// Invalid: FloatMax with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// FloatMax U:F:32, U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: FloatMax with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: FloatMax with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: FloatMax with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: FloatMin with numOperands = 0

// Invalid: FloatMin with numOperands = 1
INVALID_INST_FORM, 
// Invalid: FloatMin with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// FloatMin U:F:32, U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: FloatMin with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: FloatMin with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: FloatMin with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: DoubleMax with numOperands = 0

// Invalid: DoubleMax with numOperands = 1
INVALID_INST_FORM, 
// Invalid: DoubleMax with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// DoubleMax U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: DoubleMax with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: DoubleMax with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: DoubleMax with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: DoubleMin with numOperands = 0

// Invalid: DoubleMin with numOperands = 1
INVALID_INST_FORM, 
// Invalid: DoubleMin with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// DoubleMin U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: DoubleMin with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: DoubleMin with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: DoubleMin with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicStrongCAS8 with numOperands = 0

// Invalid: AtomicStrongCAS8 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AtomicStrongCAS8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicStrongCAS8 UD:G:8, U:G:8, UD:G:8
ENCODE_INST_FORM(Arg::UseDef, GP, Width8), ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: AtomicStrongCAS8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicStrongCAS8 U:G:32, UD:G:8, U:G:8, UD:G:8, ZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width8), 
// Invalid: AtomicStrongCAS8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicStrongCAS16 with numOperands = 0

// Invalid: AtomicStrongCAS16 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AtomicStrongCAS16 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicStrongCAS16 UD:G:16, U:G:32, UD:G:16
ENCODE_INST_FORM(Arg::UseDef, GP, Width16), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: AtomicStrongCAS16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicStrongCAS16 U:G:32, UD:G:16, U:G:32, UD:G:16, ZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width8), 
// Invalid: AtomicStrongCAS16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicStrongCAS32 with numOperands = 0

// Invalid: AtomicStrongCAS32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AtomicStrongCAS32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicStrongCAS32 UD:G:32, U:G:32, UD:G:32
ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: AtomicStrongCAS32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicStrongCAS32 U:G:32, UD:G:32, U:G:32, UD:G:32, ZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width8), 
// Invalid: AtomicStrongCAS32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicStrongCAS64 with numOperands = 0

// Invalid: AtomicStrongCAS64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AtomicStrongCAS64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicStrongCAS64 UD:G:64, U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: AtomicStrongCAS64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicStrongCAS64 U:G:32, UD:G:64, U:G:64, UD:G:64, ZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width8), 
// Invalid: AtomicStrongCAS64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS8 with numOperands = 0

// Invalid: BranchAtomicStrongCAS8 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchAtomicStrongCAS8 U:G:32, UD:G:8, U:G:8, UD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: BranchAtomicStrongCAS8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS16 with numOperands = 0

// Invalid: BranchAtomicStrongCAS16 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS16 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchAtomicStrongCAS16 U:G:32, UD:G:16, U:G:32, UD:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: BranchAtomicStrongCAS16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS32 with numOperands = 0

// Invalid: BranchAtomicStrongCAS32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchAtomicStrongCAS32 U:G:32, UD:G:32, U:G:32, UD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: BranchAtomicStrongCAS32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS64 with numOperands = 0

// Invalid: BranchAtomicStrongCAS64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchAtomicStrongCAS64 U:G:32, UD:G:64, U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: BranchAtomicStrongCAS64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd8 with numOperands = 0

// Invalid: AtomicAdd8 with numOperands = 1
INVALID_INST_FORM, 
// AtomicAdd8 U:G:8, UD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: AtomicAdd8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd16 with numOperands = 0

// Invalid: AtomicAdd16 with numOperands = 1
INVALID_INST_FORM, 
// AtomicAdd16 U:G:16, UD:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: AtomicAdd16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd32 with numOperands = 0

// Invalid: AtomicAdd32 with numOperands = 1
INVALID_INST_FORM, 
// AtomicAdd32 U:G:32, UD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: AtomicAdd32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd64 with numOperands = 0

// Invalid: AtomicAdd64 with numOperands = 1
INVALID_INST_FORM, 
// AtomicAdd64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: AtomicAdd64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub8 with numOperands = 0

// Invalid: AtomicSub8 with numOperands = 1
INVALID_INST_FORM, 
// AtomicSub8 U:G:8, UD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: AtomicSub8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub16 with numOperands = 0

// Invalid: AtomicSub16 with numOperands = 1
INVALID_INST_FORM, 
// AtomicSub16 U:G:16, UD:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: AtomicSub16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub32 with numOperands = 0

// Invalid: AtomicSub32 with numOperands = 1
INVALID_INST_FORM, 
// AtomicSub32 U:G:32, UD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: AtomicSub32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub64 with numOperands = 0

// Invalid: AtomicSub64 with numOperands = 1
INVALID_INST_FORM, 
// AtomicSub64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: AtomicSub64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd8 with numOperands = 0

// Invalid: AtomicAnd8 with numOperands = 1
INVALID_INST_FORM, 
// AtomicAnd8 U:G:8, UD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: AtomicAnd8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd16 with numOperands = 0

// Invalid: AtomicAnd16 with numOperands = 1
INVALID_INST_FORM, 
// AtomicAnd16 U:G:16, UD:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: AtomicAnd16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd32 with numOperands = 0

// Invalid: AtomicAnd32 with numOperands = 1
INVALID_INST_FORM, 
// AtomicAnd32 U:G:32, UD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: AtomicAnd32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd64 with numOperands = 0

// Invalid: AtomicAnd64 with numOperands = 1
INVALID_INST_FORM, 
// AtomicAnd64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: AtomicAnd64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr8 with numOperands = 0

// Invalid: AtomicOr8 with numOperands = 1
INVALID_INST_FORM, 
// AtomicOr8 U:G:8, UD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: AtomicOr8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr16 with numOperands = 0

// Invalid: AtomicOr16 with numOperands = 1
INVALID_INST_FORM, 
// AtomicOr16 U:G:16, UD:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: AtomicOr16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr32 with numOperands = 0

// Invalid: AtomicOr32 with numOperands = 1
INVALID_INST_FORM, 
// AtomicOr32 U:G:32, UD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: AtomicOr32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr64 with numOperands = 0

// Invalid: AtomicOr64 with numOperands = 1
INVALID_INST_FORM, 
// AtomicOr64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: AtomicOr64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor8 with numOperands = 0

// Invalid: AtomicXor8 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXor8 U:G:8, UD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: AtomicXor8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor16 with numOperands = 0

// Invalid: AtomicXor16 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXor16 U:G:16, UD:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: AtomicXor16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor32 with numOperands = 0

// Invalid: AtomicXor32 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXor32 U:G:32, UD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: AtomicXor32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor64 with numOperands = 0

// Invalid: AtomicXor64 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXor64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: AtomicXor64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg8 with numOperands = 0

// AtomicNeg8 UD:G:8
ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: AtomicNeg8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg16 with numOperands = 0

// AtomicNeg16 UD:G:16
ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: AtomicNeg16 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg32 with numOperands = 0

// AtomicNeg32 UD:G:32
ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: AtomicNeg32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg64 with numOperands = 0

// AtomicNeg64 UD:G:64
ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: AtomicNeg64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot8 with numOperands = 0

// AtomicNot8 UD:G:8
ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: AtomicNot8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot16 with numOperands = 0

// AtomicNot16 UD:G:16
ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: AtomicNot16 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot32 with numOperands = 0

// AtomicNot32 UD:G:32
ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: AtomicNot32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot64 with numOperands = 0

// AtomicNot64 UD:G:64
ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: AtomicNot64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd8 with numOperands = 0

// Invalid: AtomicXchgAdd8 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXchgAdd8 UD:G:8, UD:G:8
ENCODE_INST_FORM(Arg::UseDef, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// AtomicXchgAdd8 U:G:8, UD:G:8, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: AtomicXchgAdd8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd16 with numOperands = 0

// Invalid: AtomicXchgAdd16 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXchgAdd16 UD:G:16, UD:G:16
ENCODE_INST_FORM(Arg::UseDef, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// AtomicXchgAdd16 U:G:16, UD:G:16, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: AtomicXchgAdd16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd32 with numOperands = 0

// Invalid: AtomicXchgAdd32 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXchgAdd32 UD:G:32, UD:G:32
ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// AtomicXchgAdd32 U:G:32, UD:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: AtomicXchgAdd32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd64 with numOperands = 0

// Invalid: AtomicXchgAdd64 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXchgAdd64 UD:G:64, UD:G:64
ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// AtomicXchgAdd64 U:G:64, UD:G:64, ZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width64), 
// Invalid: AtomicXchgAdd64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg8 with numOperands = 0

// Invalid: AtomicXchg8 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXchg8 UD:G:8, UD:G:8
ENCODE_INST_FORM(Arg::UseDef, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// AtomicXchg8 U:G:8, UD:G:8, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: AtomicXchg8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg16 with numOperands = 0

// Invalid: AtomicXchg16 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXchg16 UD:G:16, UD:G:16
ENCODE_INST_FORM(Arg::UseDef, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// AtomicXchg16 U:G:16, UD:G:16, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: AtomicXchg16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg32 with numOperands = 0

// Invalid: AtomicXchg32 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXchg32 UD:G:32, UD:G:32
ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// AtomicXchg32 U:G:32, UD:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: AtomicXchg32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg64 with numOperands = 0

// Invalid: AtomicXchg64 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXchg64 UD:G:64, UD:G:64
ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// AtomicXchg64 U:G:64, UD:G:64, ZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width64), 
// Invalid: AtomicXchg64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink8 with numOperands = 0

// Invalid: LoadLink8 with numOperands = 1
INVALID_INST_FORM, 
// LoadLink8 U:G:8, ZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width8), 
// Invalid: LoadLink8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq8 with numOperands = 0

// Invalid: LoadLinkAcq8 with numOperands = 1
INVALID_INST_FORM, 
// LoadLinkAcq8 U:G:8, ZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width8), 
// Invalid: LoadLinkAcq8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond8 with numOperands = 0

// Invalid: StoreCond8 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StoreCond8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// StoreCond8 U:G:8, D:G:8, EZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Def, GP, Width8), ENCODE_INST_FORM(Arg::EarlyZDef, GP, Width8), 
// Invalid: StoreCond8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel8 with numOperands = 0

// Invalid: StoreCondRel8 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StoreCondRel8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// StoreCondRel8 U:G:8, D:G:8, EZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Def, GP, Width8), ENCODE_INST_FORM(Arg::EarlyZDef, GP, Width8), 
// Invalid: StoreCondRel8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink16 with numOperands = 0

// Invalid: LoadLink16 with numOperands = 1
INVALID_INST_FORM, 
// LoadLink16 U:G:16, ZD:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width16), 
// Invalid: LoadLink16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq16 with numOperands = 0

// Invalid: LoadLinkAcq16 with numOperands = 1
INVALID_INST_FORM, 
// LoadLinkAcq16 U:G:16, ZD:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width16), 
// Invalid: LoadLinkAcq16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond16 with numOperands = 0

// Invalid: StoreCond16 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StoreCond16 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// StoreCond16 U:G:16, D:G:16, EZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::Def, GP, Width16), ENCODE_INST_FORM(Arg::EarlyZDef, GP, Width8), 
// Invalid: StoreCond16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel16 with numOperands = 0

// Invalid: StoreCondRel16 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StoreCondRel16 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// StoreCondRel16 U:G:16, D:G:16, EZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::Def, GP, Width16), ENCODE_INST_FORM(Arg::EarlyZDef, GP, Width8), 
// Invalid: StoreCondRel16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink32 with numOperands = 0

// Invalid: LoadLink32 with numOperands = 1
INVALID_INST_FORM, 
// LoadLink32 U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: LoadLink32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq32 with numOperands = 0

// Invalid: LoadLinkAcq32 with numOperands = 1
INVALID_INST_FORM, 
// LoadLinkAcq32 U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: LoadLinkAcq32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond32 with numOperands = 0

// Invalid: StoreCond32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StoreCond32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// StoreCond32 U:G:32, D:G:32, EZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width32), ENCODE_INST_FORM(Arg::EarlyZDef, GP, Width8), 
// Invalid: StoreCond32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel32 with numOperands = 0

// Invalid: StoreCondRel32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StoreCondRel32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// StoreCondRel32 U:G:32, D:G:32, EZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width32), ENCODE_INST_FORM(Arg::EarlyZDef, GP, Width8), 
// Invalid: StoreCondRel32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkPair32 with numOperands = 0

// Invalid: LoadLinkPair32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: LoadLinkPair32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// LoadLinkPair32 U:G:64, D:G:32, D:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width32), 
// Invalid: LoadLinkPair32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkPair32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkPair32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink64 with numOperands = 0

// Invalid: LoadLink64 with numOperands = 1
INVALID_INST_FORM, 
// LoadLink64 U:G:64, ZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width64), 
// Invalid: LoadLink64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq64 with numOperands = 0

// Invalid: LoadLinkAcq64 with numOperands = 1
INVALID_INST_FORM, 
// LoadLinkAcq64 U:G:64, ZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width64), 
// Invalid: LoadLinkAcq64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondPair32 with numOperands = 0

// Invalid: StoreCondPair32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StoreCondPair32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondPair32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// StoreCondPair32 U:G:32, U:G:32, D:G:64, EZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width64), ENCODE_INST_FORM(Arg::EarlyZDef, GP, Width8), 
// Invalid: StoreCondPair32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondPair32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond64 with numOperands = 0

// Invalid: StoreCond64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StoreCond64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// StoreCond64 U:G:64, D:G:64, EZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), ENCODE_INST_FORM(Arg::EarlyZDef, GP, Width8), 
// Invalid: StoreCond64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel64 with numOperands = 0

// Invalid: StoreCondRel64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StoreCondRel64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// StoreCondRel64 U:G:64, D:G:64, EZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), ENCODE_INST_FORM(Arg::EarlyZDef, GP, Width8), 
// Invalid: StoreCondRel64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Depend32 with numOperands = 0

// Invalid: Depend32 with numOperands = 1
INVALID_INST_FORM, 
// Depend32 U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Depend32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Depend32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Depend32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Depend32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Depend64 with numOperands = 0

// Invalid: Depend64 with numOperands = 1
INVALID_INST_FORM, 
// Depend64 U:G:64, ZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width64), 
// Invalid: Depend64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Depend64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Depend64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Depend64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgOr8 with numOperands = 0

// Invalid: AtomicXchgOr8 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AtomicXchgOr8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicXchgOr8 U:G:8, UD:G:8, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: AtomicXchgOr8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgOr8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgOr8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgOr16 with numOperands = 0

// Invalid: AtomicXchgOr16 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AtomicXchgOr16 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicXchgOr16 U:G:16, UD:G:16, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: AtomicXchgOr16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgOr16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgOr16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgOr32 with numOperands = 0

// Invalid: AtomicXchgOr32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AtomicXchgOr32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicXchgOr32 U:G:32, UD:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: AtomicXchgOr32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgOr32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgOr32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgOr64 with numOperands = 0

// Invalid: AtomicXchgOr64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AtomicXchgOr64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicXchgOr64 U:G:64, UD:G:64, ZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width64), 
// Invalid: AtomicXchgOr64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgOr64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgOr64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgClear8 with numOperands = 0

// Invalid: AtomicXchgClear8 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AtomicXchgClear8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicXchgClear8 U:G:8, UD:G:8, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: AtomicXchgClear8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgClear8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgClear8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgClear16 with numOperands = 0

// Invalid: AtomicXchgClear16 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AtomicXchgClear16 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicXchgClear16 U:G:16, UD:G:16, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: AtomicXchgClear16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgClear16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgClear16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgClear32 with numOperands = 0

// Invalid: AtomicXchgClear32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AtomicXchgClear32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicXchgClear32 U:G:32, UD:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: AtomicXchgClear32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgClear32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgClear32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgClear64 with numOperands = 0

// Invalid: AtomicXchgClear64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AtomicXchgClear64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicXchgClear64 U:G:64, UD:G:64, ZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width64), 
// Invalid: AtomicXchgClear64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgClear64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgClear64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgXor8 with numOperands = 0

// Invalid: AtomicXchgXor8 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AtomicXchgXor8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicXchgXor8 U:G:8, UD:G:8, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: AtomicXchgXor8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgXor8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgXor8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgXor16 with numOperands = 0

// Invalid: AtomicXchgXor16 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AtomicXchgXor16 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicXchgXor16 U:G:16, UD:G:16, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: AtomicXchgXor16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgXor16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgXor16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgXor32 with numOperands = 0

// Invalid: AtomicXchgXor32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AtomicXchgXor32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicXchgXor32 U:G:32, UD:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: AtomicXchgXor32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgXor32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgXor32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgXor64 with numOperands = 0

// Invalid: AtomicXchgXor64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AtomicXchgXor64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicXchgXor64 U:G:64, UD:G:64, ZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width64), 
// Invalid: AtomicXchgXor64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgXor64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgXor64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Compare32 with numOperands = 0

// Invalid: Compare32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Compare32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Compare32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Compare32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Compare32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Compare32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Compare64 with numOperands = 0

// Invalid: Compare64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Compare64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Compare64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Compare64 U:G:32, U:G:64, U:G:64, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Compare64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Compare64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Test32 with numOperands = 0

// Invalid: Test32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Test32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Test32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Test32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Test32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Test32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Test64 with numOperands = 0

// Invalid: Test64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Test64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Test64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Test64 U:G:32, U:G:64, U:G:64, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Test64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Test64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareDouble with numOperands = 0

// Invalid: CompareDouble with numOperands = 1
INVALID_INST_FORM, 
// Invalid: CompareDouble with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// CompareDouble U:G:32, U:F:64, U:F:64, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: CompareDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareFloat with numOperands = 0

// Invalid: CompareFloat with numOperands = 1
INVALID_INST_FORM, 
// Invalid: CompareFloat with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// CompareFloat U:G:32, U:F:32, U:F:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: CompareFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareDoubleWithZero with numOperands = 0

// Invalid: CompareDoubleWithZero with numOperands = 1
INVALID_INST_FORM, 
// Invalid: CompareDoubleWithZero with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// CompareDoubleWithZero U:G:32, U:F:64, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: CompareDoubleWithZero with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareDoubleWithZero with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareDoubleWithZero with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareFloatWithZero with numOperands = 0

// Invalid: CompareFloatWithZero with numOperands = 1
INVALID_INST_FORM, 
// Invalid: CompareFloatWithZero with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// CompareFloatWithZero U:G:32, U:F:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: CompareFloatWithZero with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareFloatWithZero with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareFloatWithZero with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Branch8 with numOperands = 0

// Invalid: Branch8 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Branch8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Branch8 U:G:32, U:G:8, U:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, GP, Width8), 
// Invalid: Branch8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Branch8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Branch8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Branch32 with numOperands = 0

// Invalid: Branch32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Branch32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Branch32 U:G:32, U:G:32, U:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), 
// Invalid: Branch32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Branch32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Branch32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Branch64 with numOperands = 0

// Invalid: Branch64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Branch64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Branch64 U:G:32, U:G:64, U:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), 
// Invalid: Branch64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Branch64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Branch64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTest8 with numOperands = 0

// Invalid: BranchTest8 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchTest8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchTest8 U:G:32, U:G:8, U:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, GP, Width8), 
// Invalid: BranchTest8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTest8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTest8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTest32 with numOperands = 0

// Invalid: BranchTest32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchTest32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchTest32 U:G:32, U:G:32, U:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), 
// Invalid: BranchTest32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTest32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTest32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTest64 with numOperands = 0

// Invalid: BranchTest64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchTest64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchTest64 U:G:32, U:G:64, U:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), 
// Invalid: BranchTest64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTest64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTest64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTestBit64 with numOperands = 0

// Invalid: BranchTestBit64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchTestBit64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchTestBit64 U:G:32, U:G:64, U:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width8), 
// Invalid: BranchTestBit64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTestBit64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTestBit64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTestBit32 with numOperands = 0

// Invalid: BranchTestBit32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchTestBit32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchTestBit32 U:G:32, U:G:32, U:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width8), 
// Invalid: BranchTestBit32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTestBit32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTestBit32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchDouble with numOperands = 0

// Invalid: BranchDouble with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchDouble with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchDouble U:G:32, U:F:64, U:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), 
// Invalid: BranchDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchFloat with numOperands = 0

// Invalid: BranchFloat with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchFloat with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchFloat U:G:32, U:F:32, U:F:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), 
// Invalid: BranchFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchDoubleWithZero with numOperands = 0

// Invalid: BranchDoubleWithZero with numOperands = 1
INVALID_INST_FORM, 
// BranchDoubleWithZero U:G:32, U:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width64), 
// Invalid: BranchDoubleWithZero with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchDoubleWithZero with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchDoubleWithZero with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchDoubleWithZero with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchFloatWithZero with numOperands = 0

// Invalid: BranchFloatWithZero with numOperands = 1
INVALID_INST_FORM, 
// BranchFloatWithZero U:G:32, U:F:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), 
// Invalid: BranchFloatWithZero with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchFloatWithZero with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchFloatWithZero with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchFloatWithZero with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAdd32 with numOperands = 0

// Invalid: BranchAdd32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchAdd32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchAdd32 U:G:32, U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// BranchAdd32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: BranchAdd32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAdd32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAdd64 with numOperands = 0

// Invalid: BranchAdd64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchAdd64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchAdd64 U:G:32, U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// BranchAdd64 U:G:32, U:G:64, U:G:64, ZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width64), 
// Invalid: BranchAdd64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAdd64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchMul32 with numOperands = 0

// Invalid: BranchMul32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchMul32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchMul32 U:G:32, U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// BranchMul32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: BranchMul32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchMul32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchMul64 with numOperands = 0

// Invalid: BranchMul64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchMul64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchMul64 U:G:32, U:G:64, UZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseZDef, GP, Width64), 
// Invalid: BranchMul64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchMul64 U:G:32, U:G:64, U:G:64, S:G:64, ZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Scratch, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width64), 
// Invalid: BranchMul64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchSub32 with numOperands = 0

// Invalid: BranchSub32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchSub32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchSub32 U:G:32, U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// BranchSub32 U:G:32, U:G:32, U:G:32, EZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::EarlyZDef, GP, Width32), 
// Invalid: BranchSub32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchSub32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchSub64 with numOperands = 0

// Invalid: BranchSub64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchSub64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchSub64 U:G:32, U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// BranchSub64 U:G:32, U:G:64, U:G:64, EZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::EarlyZDef, GP, Width64), 
// Invalid: BranchSub64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchSub64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchNeg32 with numOperands = 0

// Invalid: BranchNeg32 with numOperands = 1
INVALID_INST_FORM, 
// BranchNeg32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Invalid: BranchNeg32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchNeg32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchNeg32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchNeg32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchNeg64 with numOperands = 0

// Invalid: BranchNeg64 with numOperands = 1
INVALID_INST_FORM, 
// BranchNeg64 U:G:32, UZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width64), 
// Invalid: BranchNeg64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchNeg64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchNeg64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchNeg64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionally32 with numOperands = 0

// Invalid: MoveConditionally32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveConditionally32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionally32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionally32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveConditionally32 U:G:32, U:G:32, U:G:32, U:G:Ptr, UD:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::UseDef, GP, pointerWidth()), 
// MoveConditionally32 U:G:32, U:G:32, U:G:32, U:G:Ptr, U:G:Ptr, D:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Def, GP, pointerWidth()), 
// Invalid: MoveConditionally64 with numOperands = 0

// Invalid: MoveConditionally64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveConditionally64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionally64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionally64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveConditionally64 U:G:32, U:G:64, U:G:64, U:G:Ptr, UD:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::UseDef, GP, pointerWidth()), 
// MoveConditionally64 U:G:32, U:G:64, U:G:64, U:G:Ptr, U:G:Ptr, D:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Def, GP, pointerWidth()), 
// Invalid: MoveConditionallyTest32 with numOperands = 0

// Invalid: MoveConditionallyTest32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveConditionallyTest32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionallyTest32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionallyTest32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveConditionallyTest32 U:G:32, U:G:32, U:G:32, U:G:Ptr, UD:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::UseDef, GP, pointerWidth()), 
// MoveConditionallyTest32 U:G:32, U:G:32, U:G:32, U:G:Ptr, U:G:Ptr, D:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Def, GP, pointerWidth()), 
// Invalid: MoveConditionallyTest64 with numOperands = 0

// Invalid: MoveConditionallyTest64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveConditionallyTest64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionallyTest64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionallyTest64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveConditionallyTest64 U:G:32, U:G:64, U:G:64, U:G:Ptr, UD:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::UseDef, GP, pointerWidth()), 
// MoveConditionallyTest64 U:G:32, U:G:32, U:G:32, U:G:Ptr, U:G:Ptr, D:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Def, GP, pointerWidth()), 
// Invalid: MoveConditionallyDouble with numOperands = 0

// Invalid: MoveConditionallyDouble with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveConditionallyDouble with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionallyDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionallyDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveConditionallyDouble U:G:32, U:F:64, U:F:64, U:G:Ptr, UD:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::UseDef, GP, pointerWidth()), 
// MoveConditionallyDouble U:G:32, U:F:64, U:F:64, U:G:Ptr, U:G:Ptr, D:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Def, GP, pointerWidth()), 
// Invalid: MoveConditionallyDoubleWithZero with numOperands = 0

// Invalid: MoveConditionallyDoubleWithZero with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveConditionallyDoubleWithZero with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionallyDoubleWithZero with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveConditionallyDoubleWithZero U:G:32, U:F:64, U:G:Ptr, UD:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::UseDef, GP, pointerWidth()), 
// MoveConditionallyDoubleWithZero U:G:32, U:F:64, U:G:Ptr, U:G:Ptr, D:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Def, GP, pointerWidth()), 
// Invalid: MoveConditionallyDoubleWithZero with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionallyFloat with numOperands = 0

// Invalid: MoveConditionallyFloat with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveConditionallyFloat with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionallyFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionallyFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveConditionallyFloat U:G:32, U:F:32, U:F:32, U:G:Ptr, UD:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::UseDef, GP, pointerWidth()), 
// MoveConditionallyFloat U:G:32, U:F:32, U:F:32, U:G:Ptr, U:G:Ptr, D:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Def, GP, pointerWidth()), 
// Invalid: MoveConditionallyFloatWithZero with numOperands = 0

// Invalid: MoveConditionallyFloatWithZero with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveConditionallyFloatWithZero with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionallyFloatWithZero with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveConditionallyFloatWithZero U:G:32, U:F:32, U:G:Ptr, UD:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::UseDef, GP, pointerWidth()), 
// MoveConditionallyFloatWithZero U:G:32, U:F:32, U:G:Ptr, U:G:Ptr, D:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Def, GP, pointerWidth()), 
// Invalid: MoveConditionallyFloatWithZero with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionally32 with numOperands = 0

// Invalid: MoveDoubleConditionally32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionally32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionally32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionally32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionally32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveDoubleConditionally32 U:G:32, U:G:32, U:G:32, U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: MoveDoubleConditionally64 with numOperands = 0

// Invalid: MoveDoubleConditionally64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionally64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionally64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionally64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionally64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveDoubleConditionally64 U:G:32, U:G:64, U:G:64, U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: MoveDoubleConditionallyTest32 with numOperands = 0

// Invalid: MoveDoubleConditionallyTest32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyTest32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyTest32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyTest32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyTest32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveDoubleConditionallyTest32 U:G:32, U:G:32, U:G:32, U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: MoveDoubleConditionallyTest64 with numOperands = 0

// Invalid: MoveDoubleConditionallyTest64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyTest64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyTest64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyTest64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyTest64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveDoubleConditionallyTest64 U:G:32, U:G:64, U:G:64, U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: MoveDoubleConditionallyDouble with numOperands = 0

// Invalid: MoveDoubleConditionallyDouble with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyDouble with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveDoubleConditionallyDouble U:G:32, U:F:64, U:F:64, U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: MoveDoubleConditionallyDoubleWithZero with numOperands = 0

// Invalid: MoveDoubleConditionallyDoubleWithZero with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyDoubleWithZero with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyDoubleWithZero with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyDoubleWithZero with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveDoubleConditionallyDoubleWithZero U:G:32, U:F:64, U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: MoveDoubleConditionallyDoubleWithZero with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyFloat with numOperands = 0

// Invalid: MoveDoubleConditionallyFloat with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyFloat with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveDoubleConditionallyFloat U:G:32, U:F:32, U:F:32, U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: MoveDoubleConditionallyFloatWithZero with numOperands = 0

// Invalid: MoveDoubleConditionallyFloatWithZero with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyFloatWithZero with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyFloatWithZero with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyFloatWithZero with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveDoubleConditionallyFloatWithZero U:G:32, U:F:32, U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: MoveDoubleConditionallyFloatWithZero with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MemoryFence 

// Invalid: MemoryFence with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MemoryFence with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MemoryFence with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MemoryFence with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MemoryFence with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MemoryFence with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// StoreFence 

// Invalid: StoreFence with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StoreFence with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreFence with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreFence with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreFence with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreFence with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// LoadFence 

// Invalid: LoadFence with numOperands = 1
INVALID_INST_FORM, 
// Invalid: LoadFence with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadFence with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadFence with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadFence with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadFence with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Jump 

// Invalid: Jump with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Jump with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Jump with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Jump with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Jump with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Jump with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// RetVoid 

// Invalid: RetVoid with numOperands = 1
INVALID_INST_FORM, 
// Invalid: RetVoid with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetVoid with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetVoid with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetVoid with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetVoid with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Ret32 with numOperands = 0

// Ret32 U:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), 
// Invalid: Ret32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Ret32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Ret32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Ret32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Ret32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Ret64 with numOperands = 0

// Ret64 U:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), 
// Invalid: Ret64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Ret64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Ret64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Ret64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Ret64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetFloat with numOperands = 0

// RetFloat U:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), 
// Invalid: RetFloat with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetDouble with numOperands = 0

// RetDouble U:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), 
// Invalid: RetDouble with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneInt64 with numOperands = 0

// Invalid: VectorReplaceLaneInt64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneInt64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorReplaceLaneInt64 U:G:8, U:G:64, UD:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, FP, Width128), 
// Invalid: VectorReplaceLaneInt64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneInt64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneInt64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneInt32 with numOperands = 0

// Invalid: VectorReplaceLaneInt32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneInt32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorReplaceLaneInt32 U:G:8, U:G:32, UD:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, FP, Width128), 
// Invalid: VectorReplaceLaneInt32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneInt32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneInt32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneInt16 with numOperands = 0

// Invalid: VectorReplaceLaneInt16 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneInt16 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorReplaceLaneInt16 U:G:8, U:G:16, UD:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, FP, Width128), 
// Invalid: VectorReplaceLaneInt16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneInt16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneInt16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneInt8 with numOperands = 0

// Invalid: VectorReplaceLaneInt8 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneInt8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorReplaceLaneInt8 U:G:8, U:G:8, UD:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, FP, Width128), 
// Invalid: VectorReplaceLaneInt8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneInt8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneInt8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneFloat64 with numOperands = 0

// Invalid: VectorReplaceLaneFloat64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneFloat64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorReplaceLaneFloat64 U:G:8, U:F:64, UD:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::UseDef, FP, Width128), 
// Invalid: VectorReplaceLaneFloat64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneFloat64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneFloat64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneFloat32 with numOperands = 0

// Invalid: VectorReplaceLaneFloat32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneFloat32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorReplaceLaneFloat32 U:G:8, U:F:32, UD:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::UseDef, FP, Width128), 
// Invalid: VectorReplaceLaneFloat32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneFloat32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorReplaceLaneFloat32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneInt64 with numOperands = 0

// Invalid: VectorExtractLaneInt64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorExtractLaneInt64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorExtractLaneInt64 U:G:8, U:F:128, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: VectorExtractLaneInt64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneInt64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneInt64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneInt32 with numOperands = 0

// Invalid: VectorExtractLaneInt32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorExtractLaneInt32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorExtractLaneInt32 U:G:8, U:F:128, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: VectorExtractLaneInt32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneInt32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneInt32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneSignedInt16 with numOperands = 0

// Invalid: VectorExtractLaneSignedInt16 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorExtractLaneSignedInt16 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorExtractLaneSignedInt16 U:G:8, U:F:128, D:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, GP, Width32), 
// Invalid: VectorExtractLaneSignedInt16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneSignedInt16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneSignedInt16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneUnsignedInt16 with numOperands = 0

// Invalid: VectorExtractLaneUnsignedInt16 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorExtractLaneUnsignedInt16 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorExtractLaneUnsignedInt16 U:G:8, U:F:128, ZD:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::ZDef, GP, Width16), 
// Invalid: VectorExtractLaneUnsignedInt16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneUnsignedInt16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneUnsignedInt16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneSignedInt8 with numOperands = 0

// Invalid: VectorExtractLaneSignedInt8 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorExtractLaneSignedInt8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorExtractLaneSignedInt8 U:G:8, U:F:128, D:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, GP, Width32), 
// Invalid: VectorExtractLaneSignedInt8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneSignedInt8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneSignedInt8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneUnsignedInt8 with numOperands = 0

// Invalid: VectorExtractLaneUnsignedInt8 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorExtractLaneUnsignedInt8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorExtractLaneUnsignedInt8 U:G:8, U:F:128, ZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::ZDef, GP, Width8), 
// Invalid: VectorExtractLaneUnsignedInt8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneUnsignedInt8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneUnsignedInt8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneFloat64 with numOperands = 0

// Invalid: VectorExtractLaneFloat64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorExtractLaneFloat64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorExtractLaneFloat64 U:G:8, U:F:128, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: VectorExtractLaneFloat64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneFloat64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneFloat64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneFloat32 with numOperands = 0

// Invalid: VectorExtractLaneFloat32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorExtractLaneFloat32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorExtractLaneFloat32 U:G:8, U:F:128, D:F:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: VectorExtractLaneFloat32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneFloat32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractLaneFloat32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatInt8 with numOperands = 0

// Invalid: VectorSplatInt8 with numOperands = 1
INVALID_INST_FORM, 
// VectorSplatInt8 U:G:8, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorSplatInt8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatInt8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatInt8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatInt8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatInt16 with numOperands = 0

// Invalid: VectorSplatInt16 with numOperands = 1
INVALID_INST_FORM, 
// VectorSplatInt16 U:G:16, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorSplatInt16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatInt16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatInt16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatInt16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatInt32 with numOperands = 0

// Invalid: VectorSplatInt32 with numOperands = 1
INVALID_INST_FORM, 
// VectorSplatInt32 U:G:32, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorSplatInt32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatInt32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatInt32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatInt32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatInt64 with numOperands = 0

// Invalid: VectorSplatInt64 with numOperands = 1
INVALID_INST_FORM, 
// VectorSplatInt64 U:G:64, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorSplatInt64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatInt64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatInt64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatInt64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatFloat32 with numOperands = 0

// Invalid: VectorSplatFloat32 with numOperands = 1
INVALID_INST_FORM, 
// VectorSplatFloat32 U:F:32, D:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorSplatFloat32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatFloat32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatFloat32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatFloat32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatFloat64 with numOperands = 0

// Invalid: VectorSplatFloat64 with numOperands = 1
INVALID_INST_FORM, 
// VectorSplatFloat64 U:F:64, D:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorSplatFloat64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatFloat64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatFloat64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSplatFloat64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareFloatingPointVectorUnordered with numOperands = 0

// Invalid: CompareFloatingPointVectorUnordered with numOperands = 1
INVALID_INST_FORM, 
// Invalid: CompareFloatingPointVectorUnordered with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareFloatingPointVectorUnordered with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// CompareFloatingPointVectorUnordered U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: CompareFloatingPointVectorUnordered with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareFloatingPointVectorUnordered with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareFloatingPointVector with numOperands = 0

// Invalid: CompareFloatingPointVector with numOperands = 1
INVALID_INST_FORM, 
// Invalid: CompareFloatingPointVector with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareFloatingPointVector with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareFloatingPointVector with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// CompareFloatingPointVector U:G:32, U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: CompareFloatingPointVector with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareIntegerVector with numOperands = 0

// Invalid: CompareIntegerVector with numOperands = 1
INVALID_INST_FORM, 
// Invalid: CompareIntegerVector with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareIntegerVector with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareIntegerVector with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// CompareIntegerVector U:G:32, U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// CompareIntegerVector U:G:32, U:G:Ptr, U:F:128, U:F:128, D:F:128, S:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: CompareIntegerVectorWithZero with numOperands = 0

// Invalid: CompareIntegerVectorWithZero with numOperands = 1
INVALID_INST_FORM, 
// Invalid: CompareIntegerVectorWithZero with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareIntegerVectorWithZero with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// CompareIntegerVectorWithZero U:G:32, U:G:Ptr, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// CompareIntegerVectorWithZero U:G:32, U:G:Ptr, U:F:128, D:F:128, S:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, GP, Width8), 
// Invalid: CompareIntegerVectorWithZero with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorUnsignedMax with numOperands = 0

// Invalid: VectorUnsignedMax with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorUnsignedMax with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorUnsignedMax U:G:Ptr, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorUnsignedMax with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorUnsignedMax with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorUnsignedMax with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorUnsignedMin with numOperands = 0

// Invalid: VectorUnsignedMin with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorUnsignedMin with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorUnsignedMin U:G:Ptr, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorUnsignedMin with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorUnsignedMin with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorUnsignedMin with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAdd with numOperands = 0

// Invalid: VectorAdd with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorAdd with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAdd with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorAdd U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorAdd with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAdd with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSub with numOperands = 0

// Invalid: VectorSub with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorSub with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSub with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorSub U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorSub with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSub with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAddSat with numOperands = 0

// Invalid: VectorAddSat with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorAddSat with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAddSat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorAddSat U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorAddSat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAddSat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSubSat with numOperands = 0

// Invalid: VectorSubSat with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorSubSat with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSubSat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorSubSat U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorSubSat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSubSat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorMul with numOperands = 0

// Invalid: VectorMul with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorMul with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorMul with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorMul U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorMul with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorMul with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorMulByElementFloat32 with numOperands = 0

// Invalid: VectorMulByElementFloat32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorMulByElementFloat32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorMulByElementFloat32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorMulByElementFloat32 U:F:128, U:F:128, U:G:8, D:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorMulByElementFloat32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorMulByElementFloat32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorMulByElementFloat64 with numOperands = 0

// Invalid: VectorMulByElementFloat64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorMulByElementFloat64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorMulByElementFloat64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorMulByElementFloat64 U:F:128, U:F:128, U:G:8, D:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorMulByElementFloat64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorMulByElementFloat64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDiv with numOperands = 0

// Invalid: VectorDiv with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorDiv with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDiv with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorDiv U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorDiv with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDiv with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorMin with numOperands = 0

// Invalid: VectorMin with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorMin with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorMin with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorMin U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorMin with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorMin with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorMax with numOperands = 0

// Invalid: VectorMax with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorMax with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorMax with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorMax U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorMax with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorMax with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorPmin with numOperands = 0

// Invalid: VectorPmin with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorPmin with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorPmin with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorPmin U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// VectorPmin U:G:Ptr, U:F:128, U:F:128, D:F:128, S:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorPmin with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorPmax with numOperands = 0

// Invalid: VectorPmax with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorPmax with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorPmax with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorPmax U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// VectorPmax U:G:Ptr, U:F:128, U:F:128, D:F:128, S:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorPmax with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorNarrow with numOperands = 0

// Invalid: VectorNarrow with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorNarrow with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorNarrow with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorNarrow with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorNarrow U:G:Ptr, U:F:128, U:F:128, D:F:128, S:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorNarrow with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorBitwiseSelect with numOperands = 0

// Invalid: VectorBitwiseSelect with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorBitwiseSelect with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorBitwiseSelect U:F:128, U:F:128, UD:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::UseDef, FP, Width128), 
// Invalid: VectorBitwiseSelect with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorBitwiseSelect with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorBitwiseSelect with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorNot with numOperands = 0

// Invalid: VectorNot with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorNot with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorNot U:G:Ptr, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorNot with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorNot with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorNot with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAnd with numOperands = 0

// Invalid: VectorAnd with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorAnd with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAnd with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorAnd U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorAnd with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAnd with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAndnot with numOperands = 0

// Invalid: VectorAndnot with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorAndnot with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAndnot with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorAndnot U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorAndnot with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAndnot with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorOr with numOperands = 0

// Invalid: VectorOr with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorOr with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorOr with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorOr U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorOr with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorOr with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorXor with numOperands = 0

// Invalid: VectorXor with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorXor with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorXor with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorXor U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorXor with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorXor with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveZeroToVector with numOperands = 0

// MoveZeroToVector D:F:128
ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: MoveZeroToVector with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveZeroToVector with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveZeroToVector with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveZeroToVector with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveZeroToVector with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorUshl with numOperands = 0

// Invalid: VectorUshl with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorUshl with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorUshl with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorUshl U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorUshl with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorUshl with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSshr with numOperands = 0

// Invalid: VectorSshr with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorSshr with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSshr with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorSshr U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorSshr with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSshr with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorUshr with numOperands = 0

// Invalid: VectorUshr with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorUshr with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorUshr with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorUshr U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorUshr with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorUshr with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSshl with numOperands = 0

// Invalid: VectorSshl with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorSshl with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSshl with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorSshl U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorSshl with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSshl with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorUshl8 with numOperands = 0

// Invalid: VectorUshl8 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorUshl8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorUshl8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorUshl8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorUshl8 U:F:128, U:F:128, D:F:128, S:F:128, S:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorUshl8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorUshr8 with numOperands = 0

// Invalid: VectorUshr8 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorUshr8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorUshr8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorUshr8 U:G:Ptr, U:F:128, U:G:8, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// VectorUshr8 U:F:128, U:F:128, D:F:128, S:F:128, S:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorUshr8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSshr8 with numOperands = 0

// Invalid: VectorSshr8 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorSshr8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSshr8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorSshr8 U:G:Ptr, U:F:128, U:G:8, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// VectorSshr8 U:F:128, U:F:128, D:F:128, S:F:128, S:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorSshr8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorHorizontalAdd with numOperands = 0

// Invalid: VectorHorizontalAdd with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorHorizontalAdd with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorHorizontalAdd U:G:Ptr, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorHorizontalAdd with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorHorizontalAdd with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorHorizontalAdd with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorZipUpper with numOperands = 0

// Invalid: VectorZipUpper with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorZipUpper with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorZipUpper with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorZipUpper U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorZipUpper with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorZipUpper with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorUnzipEven with numOperands = 0

// Invalid: VectorUnzipEven with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorUnzipEven with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorUnzipEven with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorUnzipEven U:G:Ptr, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorUnzipEven with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorUnzipEven with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractPair with numOperands = 0

// Invalid: VectorExtractPair with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorExtractPair with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractPair with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtractPair with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorExtractPair U:G:Ptr, U:G:8, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorExtractPair with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAbs with numOperands = 0

// Invalid: VectorAbs with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorAbs with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorAbs U:G:Ptr, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorAbs with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAbs with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAbs with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAbsInt64 with numOperands = 0

// Invalid: VectorAbsInt64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorAbsInt64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorAbsInt64 U:F:128, D:F:128, S:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorAbsInt64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAbsInt64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAbsInt64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorNeg with numOperands = 0

// Invalid: VectorNeg with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorNeg with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorNeg U:G:Ptr, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorNeg with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorNeg with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorNeg with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorPopcnt with numOperands = 0

// Invalid: VectorPopcnt with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorPopcnt with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorPopcnt U:G:Ptr, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorPopcnt with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorPopcnt with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorPopcnt with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorCeil with numOperands = 0

// Invalid: VectorCeil with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorCeil with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorCeil U:G:Ptr, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorCeil with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorCeil with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorCeil with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorFloor with numOperands = 0

// Invalid: VectorFloor with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorFloor with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorFloor U:G:Ptr, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorFloor with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorFloor with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorFloor with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorTrunc with numOperands = 0

// Invalid: VectorTrunc with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorTrunc with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorTrunc U:G:Ptr, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorTrunc with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorTrunc with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorTrunc with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorTruncSat with numOperands = 0

// Invalid: VectorTruncSat with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorTruncSat with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorTruncSat U:G:Ptr, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorTruncSat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorTruncSat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorTruncSat U:G:Ptr, U:F:128, D:F:128, S:G:64, S:F:128, S:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, GP, Width64), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorTruncSatUnsignedFloat32 with numOperands = 0

// Invalid: VectorTruncSatUnsignedFloat32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorTruncSatUnsignedFloat32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorTruncSatUnsignedFloat32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorTruncSatUnsignedFloat32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorTruncSatUnsignedFloat32 U:F:128, D:F:128, S:G:64, S:F:128, S:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, GP, Width64), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorTruncSatUnsignedFloat32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorTruncSatSignedFloat64 with numOperands = 0

// Invalid: VectorTruncSatSignedFloat64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorTruncSatSignedFloat64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorTruncSatSignedFloat64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorTruncSatSignedFloat64 U:F:128, D:F:128, S:G:64, S:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, GP, Width64), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorTruncSatSignedFloat64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorTruncSatSignedFloat64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorTruncSatUnsignedFloat64 with numOperands = 0

// Invalid: VectorTruncSatUnsignedFloat64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorTruncSatUnsignedFloat64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorTruncSatUnsignedFloat64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorTruncSatUnsignedFloat64 U:F:128, D:F:128, S:G:64, S:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, GP, Width64), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorTruncSatUnsignedFloat64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorTruncSatUnsignedFloat64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorConvert with numOperands = 0

// Invalid: VectorConvert with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorConvert with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorConvert U:G:Ptr, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorConvert with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorConvert with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorConvert with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorConvertUnsigned with numOperands = 0

// Invalid: VectorConvertUnsigned with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorConvertUnsigned with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorConvertUnsigned U:F:128, D:F:128, S:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorConvertUnsigned with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorConvertUnsigned with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorConvertUnsigned with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorConvertLow with numOperands = 0

// Invalid: VectorConvertLow with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorConvertLow with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorConvertLow U:G:Ptr, U:F:64, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorConvertLow with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorConvertLow with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorConvertLow with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorConvertLowSignedInt32 with numOperands = 0

// Invalid: VectorConvertLowSignedInt32 with numOperands = 1
INVALID_INST_FORM, 
// VectorConvertLowSignedInt32 U:F:64, D:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorConvertLowSignedInt32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorConvertLowSignedInt32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorConvertLowSignedInt32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorConvertLowSignedInt32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorConvertLowUnsignedInt32 with numOperands = 0

// Invalid: VectorConvertLowUnsignedInt32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorConvertLowUnsignedInt32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorConvertLowUnsignedInt32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorConvertLowUnsignedInt32 U:F:64, D:F:128, S:G:64, S:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, GP, Width64), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorConvertLowUnsignedInt32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorConvertLowUnsignedInt32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorNearest with numOperands = 0

// Invalid: VectorNearest with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorNearest with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorNearest U:G:Ptr, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorNearest with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorNearest with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorNearest with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSqrt with numOperands = 0

// Invalid: VectorSqrt with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorSqrt with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorSqrt U:G:Ptr, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorSqrt with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSqrt with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSqrt with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtendLow with numOperands = 0

// Invalid: VectorExtendLow with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorExtendLow with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorExtendLow U:G:Ptr, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorExtendLow with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtendLow with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtendLow with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtendHigh with numOperands = 0

// Invalid: VectorExtendHigh with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorExtendHigh with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorExtendHigh U:G:Ptr, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorExtendHigh with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtendHigh with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtendHigh with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorPromote with numOperands = 0

// Invalid: VectorPromote with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorPromote with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorPromote U:G:Ptr, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorPromote with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorPromote with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorPromote with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDemote with numOperands = 0

// Invalid: VectorDemote with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorDemote with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorDemote U:G:Ptr, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorDemote with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDemote with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDemote with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad8Splat with numOperands = 0

// Invalid: VectorLoad8Splat with numOperands = 1
INVALID_INST_FORM, 
// VectorLoad8Splat U:G:8, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// VectorLoad8Splat U:G:8, D:F:128, S:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorLoad8Splat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad8Splat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad8Splat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad16Splat with numOperands = 0

// Invalid: VectorLoad16Splat with numOperands = 1
INVALID_INST_FORM, 
// VectorLoad16Splat U:G:16, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorLoad16Splat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad16Splat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad16Splat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad16Splat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad32Splat with numOperands = 0

// Invalid: VectorLoad32Splat with numOperands = 1
INVALID_INST_FORM, 
// VectorLoad32Splat U:G:32, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorLoad32Splat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad32Splat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad32Splat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad32Splat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad64Splat with numOperands = 0

// Invalid: VectorLoad64Splat with numOperands = 1
INVALID_INST_FORM, 
// VectorLoad64Splat U:G:64, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorLoad64Splat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad64Splat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad64Splat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad64Splat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad8Lane with numOperands = 0

// Invalid: VectorLoad8Lane with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorLoad8Lane with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorLoad8Lane U:G:8, U:G:8, UD:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, FP, Width128), 
// Invalid: VectorLoad8Lane with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad8Lane with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad8Lane with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad16Lane with numOperands = 0

// Invalid: VectorLoad16Lane with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorLoad16Lane with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorLoad16Lane U:G:16, U:G:8, UD:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, FP, Width128), 
// Invalid: VectorLoad16Lane with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad16Lane with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad16Lane with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad32Lane with numOperands = 0

// Invalid: VectorLoad32Lane with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorLoad32Lane with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorLoad32Lane U:G:32, U:G:8, UD:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, FP, Width128), 
// Invalid: VectorLoad32Lane with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad32Lane with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad32Lane with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad64Lane with numOperands = 0

// Invalid: VectorLoad64Lane with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorLoad64Lane with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorLoad64Lane U:G:64, U:G:8, UD:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, FP, Width128), 
// Invalid: VectorLoad64Lane with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad64Lane with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorLoad64Lane with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorStore8Lane with numOperands = 0

// Invalid: VectorStore8Lane with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorStore8Lane with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorStore8Lane U:F:128, U:G:8, U:G:8
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, GP, Width8), 
// Invalid: VectorStore8Lane with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorStore8Lane with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorStore8Lane with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorStore16Lane with numOperands = 0

// Invalid: VectorStore16Lane with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorStore16Lane with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorStore16Lane U:F:128, U:G:16, U:G:8
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::Use, GP, Width8), 
// Invalid: VectorStore16Lane with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorStore16Lane with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorStore16Lane with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorStore32Lane with numOperands = 0

// Invalid: VectorStore32Lane with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorStore32Lane with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorStore32Lane U:F:128, U:G:32, U:G:8
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width8), 
// Invalid: VectorStore32Lane with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorStore32Lane with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorStore32Lane with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorStore64Lane with numOperands = 0

// Invalid: VectorStore64Lane with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorStore64Lane with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorStore64Lane U:F:128, U:G:64, U:G:8
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width8), 
// Invalid: VectorStore64Lane with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorStore64Lane with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorStore64Lane with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAnyTrue with numOperands = 0

// Invalid: VectorAnyTrue with numOperands = 1
INVALID_INST_FORM, 
// VectorAnyTrue U:F:128, ZD:G:32
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: VectorAnyTrue with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAnyTrue with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAnyTrue with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAnyTrue with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAllTrue with numOperands = 0

// Invalid: VectorAllTrue with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorAllTrue with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorAllTrue U:G:8, U:F:128, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// VectorAllTrue U:G:8, U:F:128, ZD:G:32, S:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorAllTrue with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAllTrue with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorBitmask with numOperands = 0

// Invalid: VectorBitmask with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorBitmask with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorBitmask U:G:8, U:F:128, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// VectorBitmask U:G:8, U:F:128, ZD:G:32, S:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorBitmask with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorBitmask with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtaddPairwise with numOperands = 0

// Invalid: VectorExtaddPairwise with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorExtaddPairwise with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorExtaddPairwise U:G:8, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorExtaddPairwise with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorExtaddPairwise U:G:8, U:F:128, D:F:128, S:G:64, S:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, GP, Width64), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorExtaddPairwise with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtaddPairwiseUnsignedInt16 with numOperands = 0

// Invalid: VectorExtaddPairwiseUnsignedInt16 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorExtaddPairwiseUnsignedInt16 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorExtaddPairwiseUnsignedInt16 U:F:128, D:F:128, S:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorExtaddPairwiseUnsignedInt16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtaddPairwiseUnsignedInt16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorExtaddPairwiseUnsignedInt16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAddPairwise with numOperands = 0

// Invalid: VectorAddPairwise with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorAddPairwise with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAddPairwise with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorAddPairwise U:G:8, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorAddPairwise with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAddPairwise with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAvgRound with numOperands = 0

// Invalid: VectorAvgRound with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorAvgRound with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAvgRound with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorAvgRound U:G:8, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorAvgRound with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorAvgRound with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorMulHigh with numOperands = 0

// Invalid: VectorMulHigh with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorMulHigh with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorMulHigh with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorMulHigh U:G:8, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// VectorMulHigh U:G:8, U:F:128, U:F:128, D:F:128, S:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorMulHigh with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorMulLow with numOperands = 0

// Invalid: VectorMulLow with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorMulLow with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorMulLow with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorMulLow U:G:8, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// VectorMulLow U:G:8, U:F:128, U:F:128, D:F:128, S:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorMulLow with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorMulSat with numOperands = 0

// Invalid: VectorMulSat with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorMulSat with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorMulSat U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorMulSat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorMulSat U:F:128, U:F:128, D:F:128, S:G:64, S:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, GP, Width64), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorMulSat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDotProduct with numOperands = 0

// Invalid: VectorDotProduct with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorDotProduct with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorDotProduct U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// VectorDotProduct U:F:128, U:F:128, D:F:128, S:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorDotProduct with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDotProduct with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSwizzle with numOperands = 0

// Invalid: VectorSwizzle with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorSwizzle with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorSwizzle U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorSwizzle with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSwizzle with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSwizzle with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSwizzle2 with numOperands = 0

// Invalid: VectorSwizzle2 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorSwizzle2 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSwizzle2 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorSwizzle2 U:F:128, U:F:128, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorSwizzle2 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorSwizzle2 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorFusedMulAdd with numOperands = 0

// Invalid: VectorFusedMulAdd with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorFusedMulAdd with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorFusedMulAdd with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorFusedMulAdd with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorFusedMulAdd with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorFusedMulAdd U:G:Ptr, U:F:128, U:F:128, U:F:128, D:F:128, S:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorFusedNegMulAdd with numOperands = 0

// Invalid: VectorFusedNegMulAdd with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorFusedNegMulAdd with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorFusedNegMulAdd with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorFusedNegMulAdd with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorFusedNegMulAdd with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorFusedNegMulAdd U:G:Ptr, U:F:128, U:F:128, U:F:128, D:F:128, S:F:128
ENCODE_INST_FORM(Arg::Use, GP, pointerWidth()), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), ENCODE_INST_FORM(Arg::Scratch, FP, Width128), 
// Invalid: VectorDupElementInt8 with numOperands = 0

// Invalid: VectorDupElementInt8 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorDupElementInt8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorDupElementInt8 U:G:8, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorDupElementInt8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDupElementInt8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDupElementInt8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDupElementInt16 with numOperands = 0

// Invalid: VectorDupElementInt16 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorDupElementInt16 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorDupElementInt16 U:G:8, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorDupElementInt16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDupElementInt16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDupElementInt16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDupElementInt32 with numOperands = 0

// Invalid: VectorDupElementInt32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorDupElementInt32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorDupElementInt32 U:G:8, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorDupElementInt32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDupElementInt32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDupElementInt32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDupElementInt64 with numOperands = 0

// Invalid: VectorDupElementInt64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorDupElementInt64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorDupElementInt64 U:G:8, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorDupElementInt64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDupElementInt64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDupElementInt64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDupElementFloat32 with numOperands = 0

// Invalid: VectorDupElementFloat32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorDupElementFloat32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorDupElementFloat32 U:G:8, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorDupElementFloat32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDupElementFloat32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDupElementFloat32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDupElementFloat64 with numOperands = 0

// Invalid: VectorDupElementFloat64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: VectorDupElementFloat64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// VectorDupElementFloat64 U:G:8, U:F:128, D:F:128
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, FP, Width128), ENCODE_INST_FORM(Arg::Def, FP, Width128), 
// Invalid: VectorDupElementFloat64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDupElementFloat64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: VectorDupElementFloat64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Oops 

// Invalid: Oops with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Oops with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Oops with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Oops with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Oops with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Oops with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: EntrySwitch with numOperands = 0

// Invalid: EntrySwitch with numOperands = 1
INVALID_INST_FORM, 
// Invalid: EntrySwitch with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: EntrySwitch with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: EntrySwitch with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: EntrySwitch with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: EntrySwitch with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Shuffle with numOperands = 0

// Invalid: Shuffle with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Shuffle with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Shuffle with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Shuffle with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Shuffle with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Shuffle with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Patch with numOperands = 0

// Invalid: Patch with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Patch with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Patch with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Patch with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Patch with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Patch with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CCall with numOperands = 0

// Invalid: CCall with numOperands = 1
INVALID_INST_FORM, 
// Invalid: CCall with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CCall with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CCall with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CCall with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CCall with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ColdCCall with numOperands = 0

// Invalid: ColdCCall with numOperands = 1
INVALID_INST_FORM, 
// Invalid: ColdCCall with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ColdCCall with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ColdCCall with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ColdCCall with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ColdCCall with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: WasmBoundsCheck with numOperands = 0

// Invalid: WasmBoundsCheck with numOperands = 1
INVALID_INST_FORM, 
// Invalid: WasmBoundsCheck with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: WasmBoundsCheck with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: WasmBoundsCheck with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: WasmBoundsCheck with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: WasmBoundsCheck with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
};
void Inst::forEachArgCustom(ScopedLambda<EachArgCallback> lambda)
{
switch (kind.opcode) {
case Opcode::EntrySwitch:
EntrySwitchCustom::forEachArg(*this, lambda);
break;
case Opcode::Shuffle:
ShuffleCustom::forEachArg(*this, lambda);
break;
case Opcode::Patch:
PatchCustom::forEachArg(*this, lambda);
break;
case Opcode::CCall:
CCallCustom::forEachArg(*this, lambda);
break;
case Opcode::ColdCCall:
ColdCCallCustom::forEachArg(*this, lambda);
break;
case Opcode::WasmBoundsCheck:
WasmBoundsCheckCustom::forEachArg(*this, lambda);
break;
default:
dataLog("Bad call to forEachArgCustom, not custom opcode: ", kind, "\n");
RELEASE_ASSERT_NOT_REACHED();
}
}
bool Inst::isValidForm()
{
switch (this->kind.opcode) {
case Opcode::Nop:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Opcode::Add32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AddZeroExtend64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!isAddZeroExtend64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AddSignExtend64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!isAddSignExtend64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(ARM_THUMB2)
if (isX86() || isARM_THUMB2()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AddDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AddFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Sub32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Sub64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(ARM_THUMB2)
if (isX86() || isARM_THUMB2()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SubDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64) || CPU(X86_64)
if (isARM_THUMB2() || isARM64() || isX86_64_AVX()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SubFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64) || CPU(X86_64)
if (isARM_THUMB2() || isARM64() || isX86_64_AVX()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Neg32:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Neg64:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::NegateDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::NegateFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Mul32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::UMull32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(ARM_THUMB2)
if (isX86() || isARM_THUMB2()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Mul64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplyAdd32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplyAdd64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplyAddSignExtend32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplyAddZeroExtend32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplySub32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplySub64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplySubSignExtend32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplySubZeroExtend32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplyNeg32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplyNeg64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplyNegSignExtend32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplyNegZeroExtend32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplySignExtend32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplyZeroExtend32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MulHigh32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::UMulHigh32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MulHigh64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::UMulHigh64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86MulHigh32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86MulHigh32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86UMulHigh32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86UMulHigh32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86MulHigh64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86MulHigh64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86UMulHigh64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86UMulHigh64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Div32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::UDiv32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Div64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::UDiv64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MulDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MulFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplyNegDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplyNegFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::DivDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64) || CPU(X86_64)
if (isARM_THUMB2() || isARM64() || isX86_64_AVX()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::DivFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64) || CPU(X86_64)
if (isARM_THUMB2() || isARM64() || isX86_64_AVX()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86ConvertToDoubleWord32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86ConvertToDoubleWord32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86ConvertToQuadWord64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86ConvertToQuadWord64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86Div32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86Div32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86UDiv32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86UDiv32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86Div64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86Div64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86UDiv64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86UDiv64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Lea32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (args[0].isStack() && args[0].stackSlot()->isSpill())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Lea64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (args[0].isStack() && args[0].stackSlot()->isSpill())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::And32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidBitImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(ARM_THUMB2)
if (isX86() || isARM_THUMB2()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::And64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidBitImm64Form(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AndDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AndFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::OrDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::OrFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::XorDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::XorFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Lshift32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isLshift32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Lshift64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isLshift64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Rshift32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isRshift32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Rshift64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isRshift64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Urshift32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isUrshift32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Urshift64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isUrshift64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RotateRight32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isRotateRight32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RotateRight64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isRotateRight64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RotateLeft32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isRotateLeft32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2)
if (isARM_THUMB2()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2)
if (isARM_THUMB2()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RotateLeft64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isRotateLeft64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Or32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidBitImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Or64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidBitImm64Form(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xor32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidBitImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2)
if (isARM_THUMB2()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xor64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidBitImm64Form(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Not32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Not64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AbsDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AbsFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CeilDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CeilFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::FloorDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::FloorFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::TruncDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::TruncFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SqrtDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SqrtFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ConvertInt32ToDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ConvertInt64ToDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ConvertInt32ToFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ConvertInt64ToFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ConvertUInt32ToDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ConvertUInt32ToFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CountLeadingZeros32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CountLeadingZeros64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ConvertDoubleToFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ConvertFloatToDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Move:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), pointerWidth()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::BigImm:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), pointerWidth()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::ZeroReg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), pointerWidth()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Swap32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Swap64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveWithIncrement64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::PreIndex:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidIncrementIndexForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::PostIndex:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidIncrementIndexForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::PreIndex:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIncrementIndexForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::PostIndex:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIncrementIndexForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Move32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64) || CPU(ARM_THUMB2)
if (isX86() || isX86_64() || isARM_THUMB2()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::ZeroReg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveWithIncrement32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::PreIndex:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidIncrementIndexForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::PostIndex:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidIncrementIndexForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::PreIndex:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIncrementIndexForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::PostIndex:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIncrementIndexForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadPair32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadPair64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StorePair32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::ZeroReg:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::ZeroReg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::ZeroReg:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StorePair64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::ZeroReg:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::ZeroReg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::ZeroReg:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SignExtend8To64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SignExtend16To64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SignExtend32To64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ZeroExtend8To32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width8))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SignExtend8To32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width8))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ZeroExtend16To32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width16))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SignExtend16To32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width16))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadPairFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadPairDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StorePairFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StorePairDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveVector:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width128))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width128))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveZeroToDouble:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveZeroToFloat:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Move64ToDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::FPImm64:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidFPImm64Form(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(ARM_THUMB2)
if (isX86() || isARM_THUMB2()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Move32ToDoubleHi:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(ARM_THUMB2)
if (isX86() || isARM_THUMB2()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Move32ToFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::FPImm32:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidFPImm32Form(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleTo64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(ARM_THUMB2)
if (isX86() || isARM_THUMB2()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleHiTo32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(ARM_THUMB2)
if (isX86() || isARM_THUMB2()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveFloatTo32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Load8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width8))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadAcq8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Store8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Index:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::ZeroReg:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Load8SignedExtendTo32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width8))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadAcq8SignedExtendTo32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Load16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width16))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadAcq16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Load16SignedExtendTo32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width16))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadAcq16SignedExtendTo32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Store16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Index:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::ZeroReg:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadAcq32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadAcq64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xchg8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xchg16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xchg32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xchg64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ExtractUnsignedBitfield32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ExtractUnsignedBitfield64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::InsertUnsignedBitfieldInZero32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::InsertUnsignedBitfieldInZero64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::InsertBitField32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::InsertBitField64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ClearBitField32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ClearBitField64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ClearBitsWithMask32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ClearBitsWithMask64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ReverseBits64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ReverseBits32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::OrNot32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::OrNot64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::XorNot32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::XorNot64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::XorNotLeftShift32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::XorNotRightShift32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::XorNotUnsignedRightShift32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::XorNotLeftShift64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::XorNotRightShift64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::XorNotUnsignedRightShift64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ExtractInsertBitfieldAtLowEnd32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ExtractInsertBitfieldAtLowEnd64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::InsertSignedBitfieldInZero32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::InsertSignedBitfieldInZero64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ExtractSignedBitfield32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ExtractSignedBitfield64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ExtractRegister32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ExtractRegister64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AddLeftShift32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AddRightShift32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AddUnsignedRightShift32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AddLeftShift64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AddRightShift64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AddUnsignedRightShift64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SubLeftShift32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SubRightShift32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SubUnsignedRightShift32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SubLeftShift64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SubRightShift64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SubUnsignedRightShift64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AndLeftShift32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AndRightShift32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AndUnsignedRightShift32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AndLeftShift64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AndRightShift64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AndUnsignedRightShift64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::XorLeftShift32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::XorRightShift32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::XorUnsignedRightShift32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::XorLeftShift64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::XorRightShift64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::XorUnsignedRightShift64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::OrLeftShift32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::OrRightShift32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::OrUnsignedRightShift32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::OrLeftShift64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::OrRightShift64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::OrUnsignedRightShift64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::FloatMax:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::FloatMin:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::DoubleMax:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::DoubleMin:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS8:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[3].offset()))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS8Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[3].scale(), args[3].offset(), Width8))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS8Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS8Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[2].scale(), args[2].offset(), Width8))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS8Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::SimpleAddr:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].ptr().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS16:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[3].offset()))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS16Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[3].scale(), args[3].offset(), Width16))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS16Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS16Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[2].scale(), args[2].offset(), Width16))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS16Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::SimpleAddr:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].ptr().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS32:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[3].offset()))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[3].scale(), args[3].offset(), Width32))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[2].scale(), args[2].offset(), Width32))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::SimpleAddr:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].ptr().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS64:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[3].offset()))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[3].scale(), args[3].offset(), Width64))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[2].scale(), args[2].offset(), Width64))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::SimpleAddr:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].ptr().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS8:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[3].offset()))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS8Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[3].scale(), args[3].offset(), Width8))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS8Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS16:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[3].offset()))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS16Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[3].scale(), args[3].offset(), Width16))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS16Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[3].offset()))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[3].scale(), args[3].offset(), Width32))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[3].offset()))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[3].scale(), args[3].offset(), Width64))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg8:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg16:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg32:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg64:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot8:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot16:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot32:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot64:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchg8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchg16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchg32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchg64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLink8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCond8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCondRel8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLink16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCond16:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCondRel16:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLink32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCond32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCondRel32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLinkPair32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2)
if (isARM_THUMB2()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLink64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCondPair32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::SimpleAddr:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2)
if (isARM_THUMB2()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].ptr().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCond64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCondRel64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Depend32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64) || CPU(ARM64)
if (isARM_THUMB2() || isARM64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Depend64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgOr8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgOr16:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgOr32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgOr64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgClear8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgClear16:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgClear32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgClear64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgXor8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgXor16:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgXor32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgXor64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64_LSE()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Compare32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Compare64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Test32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Test64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CompareDouble:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CompareFloat:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CompareDoubleWithZero:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CompareFloatWithZero:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Branch8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Branch32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Imm:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Branch64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchTest8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::BitImm:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::BitImm:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchTest32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::BitImm:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(ARM_THUMB2)
if (isX86() || isARM_THUMB2()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::BitImm:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::BitImm:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchTest64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImm64Form(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
#endif // USE(JSVALUE64)
case Arg::BitImm:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::BitImm:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::BitImm:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchTestBit64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchTestBit32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchDoubleWithZero:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchFloatWithZero:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAdd32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAdd64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchMul32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchMul64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 5:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchSub32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchSub64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchNeg32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchNeg64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionally32:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64) || CPU(ARM_THUMB2)
if (isX86_64() || isARM64() || isARM_THUMB2()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64) || CPU(ARM_THUMB2)
if (isX86_64() || isARM64() || isARM_THUMB2()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64) || CPU(ARM_THUMB2)
if (isX86_64() || isARM64() || isARM_THUMB2()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionally64:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyTest32:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64) || CPU(ARM_THUMB2)
if (isX86_64() || isARM64() || isARM_THUMB2()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64) || CPU(ARM_THUMB2)
if (isX86_64() || isARM64() || isARM_THUMB2()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64) || CPU(ARM_THUMB2)
if (isX86_64() || isARM64() || isARM_THUMB2()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyTest64:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyDouble:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 5:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyDoubleWithZero:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyFloat:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 5:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyFloatWithZero:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionally32:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64) || CPU(ARM_THUMB2)
if (isX86_64() || isARM64() || isARM_THUMB2()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64) || CPU(ARM_THUMB2)
if (isX86_64() || isARM64() || isARM_THUMB2()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionally64:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(this->kind.opcode, args[2].offset()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyTest32:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64) || CPU(ARM_THUMB2)
if (isX86_64() || isARM64() || isARM_THUMB2()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64) || CPU(ARM_THUMB2)
if (isX86_64() || isARM64() || isARM_THUMB2()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyTest64:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidAddrForm(this->kind.opcode, args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!Arg::isValidIndexForm(this->kind.opcode, args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyDouble:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyDoubleWithZero:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyFloat:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyFloatWithZero:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MemoryFence:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Opcode::StoreFence:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Opcode::LoadFence:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Opcode::Jump:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Opcode::RetVoid:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Opcode::Ret32:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Ret64:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RetFloat:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RetDouble:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorReplaceLaneInt64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorReplaceLaneInt32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorReplaceLaneInt16:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorReplaceLaneInt8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorReplaceLaneFloat64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorReplaceLaneFloat32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorExtractLaneInt64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorExtractLaneInt32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorExtractLaneSignedInt16:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorExtractLaneUnsignedInt16:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorExtractLaneSignedInt8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorExtractLaneUnsignedInt8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorExtractLaneFloat64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorExtractLaneFloat32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorSplatInt8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorSplatInt16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorSplatInt32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorSplatInt64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorSplatFloat32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorSplatFloat64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CompareFloatingPointVectorUnordered:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CompareFloatingPointVector:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::SIMDInfo:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CompareIntegerVector:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::SIMDInfo:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::SIMDInfo:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CompareIntegerVectorWithZero:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::SIMDInfo:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 5:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::SIMDInfo:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorUnsignedMax:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorUnsignedMin:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorAdd:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorSub:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorAddSat:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorSubSat:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorMul:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorMulByElementFloat32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorMulByElementFloat64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorDiv:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorMin:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorMax:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorPmin:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorPmax:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorNarrow:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorBitwiseSelect:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorNot:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorAnd:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorAndnot:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorOr:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorXor:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveZeroToVector:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorUshl:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorSshr:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorUshr:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorSshl:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorUshl8:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorUshr8:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorSshr8:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorHorizontalAdd:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorZipUpper:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorUnzipEven:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorExtractPair:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorAbs:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorAbsInt64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorNeg:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorPopcnt:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorCeil:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorFloor:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorTrunc:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorTruncSat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorTruncSatUnsignedFloat32:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorTruncSatSignedFloat64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorTruncSatUnsignedFloat64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorConvert:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorConvertUnsigned:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorConvertLow:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorConvertLowSignedInt32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorConvertLowUnsignedInt32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorNearest:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorSqrt:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorExtendLow:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorExtendHigh:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorPromote:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorDemote:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorLoad8Splat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorLoad16Splat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorLoad32Splat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorLoad64Splat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorLoad8Lane:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorLoad16Lane:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorLoad32Lane:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorLoad64Lane:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorStore8Lane:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorStore16Lane:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorStore32Lane:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorStore64Lane:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorAnyTrue:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorAllTrue:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorBitmask:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorExtaddPairwise:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 5:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorExtaddPairwiseUnsignedInt16:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorAddPairwise:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorAvgRound:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorMulHigh:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 5:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorMulLow:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 5:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorMulSat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 5:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorDotProduct:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorSwizzle:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorSwizzle2:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!isVectorSwizzle2Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorFusedMulAdd:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorFusedNegMulAdd:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::SIMDInfo:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorDupElementInt8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorDupElementInt16:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorDupElementInt32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorDupElementInt64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorDupElementFloat32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::VectorDupElementFloat64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Oops:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Opcode::EntrySwitch:
OPGEN_RETURN(EntrySwitchCustom::isValidForm(*this));
break;
case Opcode::Shuffle:
OPGEN_RETURN(ShuffleCustom::isValidForm(*this));
break;
case Opcode::Patch:
OPGEN_RETURN(PatchCustom::isValidForm(*this));
break;
case Opcode::CCall:
OPGEN_RETURN(CCallCustom::isValidForm(*this));
break;
case Opcode::ColdCCall:
OPGEN_RETURN(ColdCCallCustom::isValidForm(*this));
break;
case Opcode::WasmBoundsCheck:
OPGEN_RETURN(WasmBoundsCheckCustom::isValidForm(*this));
break;
default:
break;
}
return false;
}
bool Inst::admitsStack(unsigned argIndex)
{
switch (kind.opcode) {
case Opcode::Nop:
break;
case Opcode::Add32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
case Arg::Tmp:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AddZeroExtend64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AddSignExtend64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Add8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
case Arg::Tmp:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AddDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AddFloat:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Sub32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
case Arg::Tmp:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Sub64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
case Arg::Tmp:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SubDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SubFloat:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Neg32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Neg64:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::NegateDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::NegateFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Mul32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Imm:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::UMull32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Mul64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplyAdd32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplyAdd64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplyAddSignExtend32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplyAddZeroExtend32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplySub32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplySub64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplySubSignExtend32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplySubZeroExtend32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplyNeg32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplyNeg64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplyNegSignExtend32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplyNegZeroExtend32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplySignExtend32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplyZeroExtend32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MulHigh32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::UMulHigh32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MulHigh64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::UMulHigh64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::X86MulHigh32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::X86UMulHigh32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::X86MulHigh64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::X86UMulHigh64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Div32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::UDiv32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Div64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::UDiv64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MulDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MulFloat:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplyNegDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplyNegFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::DivDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::DivFloat:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::X86ConvertToDoubleWord32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::X86ConvertToQuadWord64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::X86Div32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::X86UDiv32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::X86Div64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::X86UDiv64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Lea32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Lea64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::And32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::BitImm:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::And64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AndDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AndFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::OrDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::OrFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::XorDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::XorFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Lshift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Lshift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Rshift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Rshift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Urshift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Urshift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::RotateRight32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::RotateRight64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::RotateLeft32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::RotateLeft64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Or32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::BitImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Or64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Xor32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::BitImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Imm:
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Xor64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
case Arg::Imm:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
case Arg::Tmp:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Not32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 1:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Not64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 1:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AbsDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AbsFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CeilDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CeilFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::FloorDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::FloorFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::TruncDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::TruncFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SqrtDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SqrtFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ConvertInt32ToDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ConvertInt64ToDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ConvertInt32ToFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ConvertInt64ToFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ConvertUInt32ToDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ConvertUInt32ToFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CountLeadingZeros32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CountLeadingZeros64:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ConvertDoubleToFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ConvertFloatToDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Move:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::BigImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
case Arg::ZeroReg:
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(true);
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::BigImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
case Arg::ZeroReg:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(ARM64)
if (isARM64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(true);
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Swap32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Swap64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveWithIncrement64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Move32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
case Arg::Imm:
break;
case Arg::ZeroReg:
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(true);
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64) || CPU(ARM_THUMB2)
if (isX86() || isX86_64() || isARM_THUMB2()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::ZeroReg:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(ARM64)
if (isARM64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(true);
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveWithIncrement32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadPair32:
switch (argIndex) {
case 0:
OPGEN_RETURN(true);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadPair64:
switch (argIndex) {
case 0:
OPGEN_RETURN(true);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StorePair32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(true);
break;
default:
break;
}
break;
case Opcode::StorePair64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(true);
break;
default:
break;
}
break;
case Opcode::SignExtend8To64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SignExtend16To64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SignExtend32To64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ZeroExtend8To32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SignExtend8To32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ZeroExtend16To32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SignExtend16To32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveFloat:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(true);
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(true);
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(true);
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(true);
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadPairFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(true);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadPairDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(true);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StorePairFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(true);
break;
default:
break;
}
break;
case Opcode::StorePairDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(true);
break;
default:
break;
}
break;
case Opcode::MoveVector:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(true);
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(true);
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveZeroToDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveZeroToFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Move64ToDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::FPImm64:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Move32ToDoubleHi:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Move32ToFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::FPImm32:
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleTo64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleHiTo32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveFloatTo32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Load8:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadAcq8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Store8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Index:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Index:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::ZeroReg:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(ARM64)
if (isARM64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Load8SignedExtendTo32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadAcq8SignedExtendTo32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Load16:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadAcq16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Load16SignedExtendTo32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadAcq16SignedExtendTo32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Store16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Index:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Index:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::ZeroReg:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(ARM64)
if (isARM64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadAcq32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreRel32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadAcq64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreRel64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Xchg8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xchg16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xchg32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xchg64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ExtractUnsignedBitfield32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ExtractUnsignedBitfield64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::InsertUnsignedBitfieldInZero32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::InsertUnsignedBitfieldInZero64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::InsertBitField32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::InsertBitField64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ClearBitField32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ClearBitField64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ClearBitsWithMask32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ClearBitsWithMask64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ReverseBits64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ReverseBits32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::OrNot32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::OrNot64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::XorNot32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::XorNot64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::XorNotLeftShift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::XorNotRightShift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::XorNotUnsignedRightShift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::XorNotLeftShift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::XorNotRightShift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::XorNotUnsignedRightShift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ExtractInsertBitfieldAtLowEnd32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ExtractInsertBitfieldAtLowEnd64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::InsertSignedBitfieldInZero32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::InsertSignedBitfieldInZero64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ExtractSignedBitfield32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ExtractSignedBitfield64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ExtractRegister32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ExtractRegister64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AddLeftShift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AddRightShift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AddUnsignedRightShift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AddLeftShift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AddRightShift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AddUnsignedRightShift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SubLeftShift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SubRightShift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SubUnsignedRightShift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SubLeftShift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SubRightShift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SubUnsignedRightShift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AndLeftShift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AndRightShift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AndUnsignedRightShift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AndLeftShift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AndRightShift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AndUnsignedRightShift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::XorLeftShift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::XorRightShift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::XorUnsignedRightShift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::XorLeftShift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::XorRightShift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::XorUnsignedRightShift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::OrLeftShift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::OrRightShift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::OrUnsignedRightShift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::OrLeftShift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::OrRightShift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::OrUnsignedRightShift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::FloatMax:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::FloatMin:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::DoubleMax:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::DoubleMin:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
case Arg::SimpleAddr:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args.size()) {
case 5:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
case Arg::SimpleAddr:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args.size()) {
case 5:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
case Arg::SimpleAddr:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args.size()) {
case 5:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
case Arg::SimpleAddr:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args.size()) {
case 5:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg8:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg16:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg64:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot8:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot16:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot64:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicXchg8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicXchg16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicXchg32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicXchg64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLink8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCond8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCondRel8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLink16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCond16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCondRel16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLink32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCond32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCondRel32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLinkPair32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLink64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCondPair32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCond64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCondRel64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Depend32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Depend64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicXchgOr8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicXchgOr16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicXchgOr32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicXchgOr64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicXchgClear8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicXchgClear16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicXchgClear32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicXchgClear64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicXchgXor8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicXchgXor16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicXchgXor32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicXchgXor64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Compare32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Compare64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Test32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
switch (args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Test64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CompareDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CompareFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CompareDoubleWithZero:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CompareFloatWithZero:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Branch8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Branch32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::RelCond:
switch (args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Branch64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::RelCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchTest8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::BitImm:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchTest32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::BitImm:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchTest64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::BitImm:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchTestBit64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchTestBit32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchDoubleWithZero:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchFloatWithZero:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchAdd32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 4:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
switch (args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args.size()) {
case 4:
switch (args[0].kind()) {
case Arg::ResCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args[0].kind()) {
case Arg::ResCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchAdd64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 4:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
switch (args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Imm:
break;
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args.size()) {
case 4:
switch (args[0].kind()) {
case Arg::ResCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchMul32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchMul64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchSub32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::ResCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchSub64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchNeg32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchNeg64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveConditionally32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveConditionally64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveConditionallyTest32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveConditionallyTest64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveConditionallyDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveConditionallyDoubleWithZero:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveConditionallyFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveConditionallyFloatWithZero:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionally32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::RelCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionally64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::RelCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyTest32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyTest64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
OPGEN_RETURN(true);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyDoubleWithZero:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyFloatWithZero:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MemoryFence:
break;
case Opcode::StoreFence:
break;
case Opcode::LoadFence:
break;
case Opcode::Jump:
break;
case Opcode::RetVoid:
break;
case Opcode::Ret32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Ret64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::RetFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::RetDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorReplaceLaneInt64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorReplaceLaneInt32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorReplaceLaneInt16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorReplaceLaneInt8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorReplaceLaneFloat64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorReplaceLaneFloat32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorExtractLaneInt64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorExtractLaneInt32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorExtractLaneSignedInt16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorExtractLaneUnsignedInt16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorExtractLaneSignedInt8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorExtractLaneUnsignedInt8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorExtractLaneFloat64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorExtractLaneFloat32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorSplatInt8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorSplatInt16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorSplatInt32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorSplatInt64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorSplatFloat32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorSplatFloat64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CompareFloatingPointVectorUnordered:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CompareFloatingPointVector:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CompareIntegerVector:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CompareIntegerVectorWithZero:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorUnsignedMax:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorUnsignedMin:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorAdd:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorSub:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorAddSat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorSubSat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorMul:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorMulByElementFloat32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorMulByElementFloat64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorDiv:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorMin:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorMax:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorPmin:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorPmax:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorNarrow:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorBitwiseSelect:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorNot:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorAnd:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorAndnot:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorOr:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorXor:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveZeroToVector:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorUshl:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorSshr:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorUshr:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorSshl:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorUshl8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorUshr8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorSshr8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorHorizontalAdd:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorZipUpper:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorUnzipEven:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorExtractPair:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorAbs:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorAbsInt64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorNeg:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorPopcnt:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorCeil:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorFloor:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorTrunc:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorTruncSat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorTruncSatUnsignedFloat32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorTruncSatSignedFloat64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorTruncSatUnsignedFloat64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorConvert:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorConvertUnsigned:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorConvertLow:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorConvertLowSignedInt32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorConvertLowUnsignedInt32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorNearest:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorSqrt:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorExtendLow:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorExtendHigh:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorPromote:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorDemote:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorLoad8Splat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorLoad16Splat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorLoad32Splat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorLoad64Splat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorLoad8Lane:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorLoad16Lane:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorLoad32Lane:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorLoad64Lane:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorStore8Lane:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorStore16Lane:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorStore32Lane:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorStore64Lane:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorAnyTrue:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorAllTrue:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorBitmask:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorExtaddPairwise:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorExtaddPairwiseUnsignedInt16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorAddPairwise:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorAvgRound:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorMulHigh:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorMulLow:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorMulSat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorDotProduct:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorSwizzle:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorSwizzle2:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorFusedMulAdd:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorFusedNegMulAdd:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorDupElementInt8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorDupElementInt16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorDupElementInt32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorDupElementInt64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorDupElementFloat32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::VectorDupElementFloat64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Oops:
break;
case Opcode::EntrySwitch:
OPGEN_RETURN(EntrySwitchCustom::admitsStack(*this, argIndex));
break;
case Opcode::Shuffle:
OPGEN_RETURN(ShuffleCustom::admitsStack(*this, argIndex));
break;
case Opcode::Patch:
OPGEN_RETURN(PatchCustom::admitsStack(*this, argIndex));
break;
case Opcode::CCall:
OPGEN_RETURN(CCallCustom::admitsStack(*this, argIndex));
break;
case Opcode::ColdCCall:
OPGEN_RETURN(ColdCCallCustom::admitsStack(*this, argIndex));
break;
case Opcode::WasmBoundsCheck:
OPGEN_RETURN(WasmBoundsCheckCustom::admitsStack(*this, argIndex));
break;
default:
break;
}
return false;
}
bool Inst::admitsExtendedOffsetAddr(unsigned argIndex)
{
switch (kind.opcode) {
case Opcode::EntrySwitch:
OPGEN_RETURN(EntrySwitchCustom::admitsExtendedOffsetAddr(*this, argIndex));
break;
case Opcode::Shuffle:
OPGEN_RETURN(ShuffleCustom::admitsExtendedOffsetAddr(*this, argIndex));
break;
case Opcode::Patch:
OPGEN_RETURN(PatchCustom::admitsExtendedOffsetAddr(*this, argIndex));
break;
case Opcode::CCall:
OPGEN_RETURN(CCallCustom::admitsExtendedOffsetAddr(*this, argIndex));
break;
case Opcode::ColdCCall:
OPGEN_RETURN(ColdCCallCustom::admitsExtendedOffsetAddr(*this, argIndex));
break;
case Opcode::WasmBoundsCheck:
OPGEN_RETURN(WasmBoundsCheckCustom::admitsExtendedOffsetAddr(*this, argIndex));
break;
default:
break;
}
return false;
}
bool Inst::isTerminal()
{
switch (kind.opcode) {
case Opcode::BranchAtomicStrongCAS8:
case Opcode::BranchAtomicStrongCAS16:
case Opcode::BranchAtomicStrongCAS32:
case Opcode::BranchAtomicStrongCAS64:
case Opcode::Branch8:
case Opcode::Branch32:
case Opcode::Branch64:
case Opcode::BranchTest8:
case Opcode::BranchTest32:
case Opcode::BranchTest64:
case Opcode::BranchTestBit64:
case Opcode::BranchTestBit32:
case Opcode::BranchDouble:
case Opcode::BranchFloat:
case Opcode::BranchDoubleWithZero:
case Opcode::BranchFloatWithZero:
case Opcode::BranchAdd32:
case Opcode::BranchAdd64:
case Opcode::BranchMul32:
case Opcode::BranchMul64:
case Opcode::BranchSub32:
case Opcode::BranchSub64:
case Opcode::BranchNeg32:
case Opcode::BranchNeg64:
case Opcode::Jump:
case Opcode::RetVoid:
case Opcode::Ret32:
case Opcode::Ret64:
case Opcode::RetFloat:
case Opcode::RetDouble:
case Opcode::Oops:
return true;
case Opcode::EntrySwitch:
return EntrySwitchCustom::isTerminal(*this);
case Opcode::Shuffle:
return ShuffleCustom::isTerminal(*this);
case Opcode::Patch:
return PatchCustom::isTerminal(*this);
case Opcode::CCall:
return CCallCustom::isTerminal(*this);
case Opcode::ColdCCall:
return ColdCCallCustom::isTerminal(*this);
case Opcode::WasmBoundsCheck:
return WasmBoundsCheckCustom::isTerminal(*this);
default:
return false;
}
}
bool Inst::hasNonArgNonControlEffects()
{
if (kind.effects)
return true;
switch (kind.opcode) {
case Opcode::LoadAcq8:
case Opcode::StoreRel8:
case Opcode::LoadAcq8SignedExtendTo32:
case Opcode::LoadAcq16:
case Opcode::LoadAcq16SignedExtendTo32:
case Opcode::StoreRel16:
case Opcode::LoadAcq32:
case Opcode::StoreRel32:
case Opcode::LoadAcq64:
case Opcode::StoreRel64:
case Opcode::Xchg8:
case Opcode::Xchg16:
case Opcode::Xchg32:
case Opcode::Xchg64:
case Opcode::AtomicStrongCAS8:
case Opcode::AtomicStrongCAS16:
case Opcode::AtomicStrongCAS32:
case Opcode::AtomicStrongCAS64:
case Opcode::BranchAtomicStrongCAS8:
case Opcode::BranchAtomicStrongCAS16:
case Opcode::BranchAtomicStrongCAS32:
case Opcode::BranchAtomicStrongCAS64:
case Opcode::AtomicAdd8:
case Opcode::AtomicAdd16:
case Opcode::AtomicAdd32:
case Opcode::AtomicAdd64:
case Opcode::AtomicSub8:
case Opcode::AtomicSub16:
case Opcode::AtomicSub32:
case Opcode::AtomicSub64:
case Opcode::AtomicAnd8:
case Opcode::AtomicAnd16:
case Opcode::AtomicAnd32:
case Opcode::AtomicAnd64:
case Opcode::AtomicOr8:
case Opcode::AtomicOr16:
case Opcode::AtomicOr32:
case Opcode::AtomicOr64:
case Opcode::AtomicXor8:
case Opcode::AtomicXor16:
case Opcode::AtomicXor32:
case Opcode::AtomicXor64:
case Opcode::AtomicNeg8:
case Opcode::AtomicNeg16:
case Opcode::AtomicNeg32:
case Opcode::AtomicNeg64:
case Opcode::AtomicNot8:
case Opcode::AtomicNot16:
case Opcode::AtomicNot32:
case Opcode::AtomicNot64:
case Opcode::AtomicXchgAdd8:
case Opcode::AtomicXchgAdd16:
case Opcode::AtomicXchgAdd32:
case Opcode::AtomicXchgAdd64:
case Opcode::AtomicXchg8:
case Opcode::AtomicXchg16:
case Opcode::AtomicXchg32:
case Opcode::AtomicXchg64:
case Opcode::LoadLink8:
case Opcode::LoadLinkAcq8:
case Opcode::StoreCond8:
case Opcode::StoreCondRel8:
case Opcode::LoadLink16:
case Opcode::LoadLinkAcq16:
case Opcode::StoreCond16:
case Opcode::StoreCondRel16:
case Opcode::LoadLink32:
case Opcode::LoadLinkAcq32:
case Opcode::StoreCond32:
case Opcode::StoreCondRel32:
case Opcode::LoadLinkPair32:
case Opcode::LoadLink64:
case Opcode::LoadLinkAcq64:
case Opcode::StoreCondPair32:
case Opcode::StoreCond64:
case Opcode::StoreCondRel64:
case Opcode::AtomicXchgOr8:
case Opcode::AtomicXchgOr16:
case Opcode::AtomicXchgOr32:
case Opcode::AtomicXchgOr64:
case Opcode::AtomicXchgClear8:
case Opcode::AtomicXchgClear16:
case Opcode::AtomicXchgClear32:
case Opcode::AtomicXchgClear64:
case Opcode::AtomicXchgXor8:
case Opcode::AtomicXchgXor16:
case Opcode::AtomicXchgXor32:
case Opcode::AtomicXchgXor64:
case Opcode::MemoryFence:
case Opcode::StoreFence:
case Opcode::LoadFence:
return true;
case Opcode::EntrySwitch:
return EntrySwitchCustom::hasNonArgNonControlEffects(*this);
case Opcode::Shuffle:
return ShuffleCustom::hasNonArgNonControlEffects(*this);
case Opcode::Patch:
return PatchCustom::hasNonArgNonControlEffects(*this);
case Opcode::CCall:
return CCallCustom::hasNonArgNonControlEffects(*this);
case Opcode::ColdCCall:
return ColdCCallCustom::hasNonArgNonControlEffects(*this);
case Opcode::WasmBoundsCheck:
return WasmBoundsCheckCustom::hasNonArgNonControlEffects(*this);
default:
return false;
}
}
bool Inst::hasNonArgEffects()
{
if (kind.effects)
return true;
switch (kind.opcode) {
case Opcode::LoadAcq8:
case Opcode::StoreRel8:
case Opcode::LoadAcq8SignedExtendTo32:
case Opcode::LoadAcq16:
case Opcode::LoadAcq16SignedExtendTo32:
case Opcode::StoreRel16:
case Opcode::LoadAcq32:
case Opcode::StoreRel32:
case Opcode::LoadAcq64:
case Opcode::StoreRel64:
case Opcode::Xchg8:
case Opcode::Xchg16:
case Opcode::Xchg32:
case Opcode::Xchg64:
case Opcode::AtomicStrongCAS8:
case Opcode::AtomicStrongCAS16:
case Opcode::AtomicStrongCAS32:
case Opcode::AtomicStrongCAS64:
case Opcode::BranchAtomicStrongCAS8:
case Opcode::BranchAtomicStrongCAS16:
case Opcode::BranchAtomicStrongCAS32:
case Opcode::BranchAtomicStrongCAS64:
case Opcode::AtomicAdd8:
case Opcode::AtomicAdd16:
case Opcode::AtomicAdd32:
case Opcode::AtomicAdd64:
case Opcode::AtomicSub8:
case Opcode::AtomicSub16:
case Opcode::AtomicSub32:
case Opcode::AtomicSub64:
case Opcode::AtomicAnd8:
case Opcode::AtomicAnd16:
case Opcode::AtomicAnd32:
case Opcode::AtomicAnd64:
case Opcode::AtomicOr8:
case Opcode::AtomicOr16:
case Opcode::AtomicOr32:
case Opcode::AtomicOr64:
case Opcode::AtomicXor8:
case Opcode::AtomicXor16:
case Opcode::AtomicXor32:
case Opcode::AtomicXor64:
case Opcode::AtomicNeg8:
case Opcode::AtomicNeg16:
case Opcode::AtomicNeg32:
case Opcode::AtomicNeg64:
case Opcode::AtomicNot8:
case Opcode::AtomicNot16:
case Opcode::AtomicNot32:
case Opcode::AtomicNot64:
case Opcode::AtomicXchgAdd8:
case Opcode::AtomicXchgAdd16:
case Opcode::AtomicXchgAdd32:
case Opcode::AtomicXchgAdd64:
case Opcode::AtomicXchg8:
case Opcode::AtomicXchg16:
case Opcode::AtomicXchg32:
case Opcode::AtomicXchg64:
case Opcode::LoadLink8:
case Opcode::LoadLinkAcq8:
case Opcode::StoreCond8:
case Opcode::StoreCondRel8:
case Opcode::LoadLink16:
case Opcode::LoadLinkAcq16:
case Opcode::StoreCond16:
case Opcode::StoreCondRel16:
case Opcode::LoadLink32:
case Opcode::LoadLinkAcq32:
case Opcode::StoreCond32:
case Opcode::StoreCondRel32:
case Opcode::LoadLinkPair32:
case Opcode::LoadLink64:
case Opcode::LoadLinkAcq64:
case Opcode::StoreCondPair32:
case Opcode::StoreCond64:
case Opcode::StoreCondRel64:
case Opcode::AtomicXchgOr8:
case Opcode::AtomicXchgOr16:
case Opcode::AtomicXchgOr32:
case Opcode::AtomicXchgOr64:
case Opcode::AtomicXchgClear8:
case Opcode::AtomicXchgClear16:
case Opcode::AtomicXchgClear32:
case Opcode::AtomicXchgClear64:
case Opcode::AtomicXchgXor8:
case Opcode::AtomicXchgXor16:
case Opcode::AtomicXchgXor32:
case Opcode::AtomicXchgXor64:
case Opcode::Branch8:
case Opcode::Branch32:
case Opcode::Branch64:
case Opcode::BranchTest8:
case Opcode::BranchTest32:
case Opcode::BranchTest64:
case Opcode::BranchTestBit64:
case Opcode::BranchTestBit32:
case Opcode::BranchDouble:
case Opcode::BranchFloat:
case Opcode::BranchDoubleWithZero:
case Opcode::BranchFloatWithZero:
case Opcode::BranchAdd32:
case Opcode::BranchAdd64:
case Opcode::BranchMul32:
case Opcode::BranchMul64:
case Opcode::BranchSub32:
case Opcode::BranchSub64:
case Opcode::BranchNeg32:
case Opcode::BranchNeg64:
case Opcode::MemoryFence:
case Opcode::StoreFence:
case Opcode::LoadFence:
case Opcode::Jump:
case Opcode::RetVoid:
case Opcode::Ret32:
case Opcode::Ret64:
case Opcode::RetFloat:
case Opcode::RetDouble:
case Opcode::Oops:
return true;
case Opcode::EntrySwitch:
return EntrySwitchCustom::hasNonArgEffects(*this);
case Opcode::Shuffle:
return ShuffleCustom::hasNonArgEffects(*this);
case Opcode::Patch:
return PatchCustom::hasNonArgEffects(*this);
case Opcode::CCall:
return CCallCustom::hasNonArgEffects(*this);
case Opcode::ColdCCall:
return ColdCCallCustom::hasNonArgEffects(*this);
case Opcode::WasmBoundsCheck:
return WasmBoundsCheckCustom::hasNonArgEffects(*this);
default:
return false;
}
}
CCallHelpers::Jump Inst::generate(CCallHelpers& jit, GenerationContext& context)
{
UNUSED_PARAM(jit);
UNUSED_PARAM(context);
CCallHelpers::Jump result;
switch (this->kind.opcode) {
case Opcode::Nop:
jit.nop();
OPGEN_RETURN(result);
break;
break;
case Opcode::Add32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
jit.add32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Tmp:
jit.add32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.add32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.add32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.add32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.add32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.add32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Tmp:
jit.add32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.add32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.add32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AddZeroExtend64:
#if CPU(ARM64)
if (isARM64()) {
jit.addZeroExtend64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AddSignExtend64:
#if CPU(ARM64)
if (isARM64()) {
jit.addSignExtend64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::Add8:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.add8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.add8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.add8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.add8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add16:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.add16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.add16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.add16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.add16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.add64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.add64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.add64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.add64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.add64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.add64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.add64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.add64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.add64(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.add64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 6:
#if CPU(X86) || CPU(ARM_THUMB2)
if (isX86() || isARM_THUMB2()) {
jit.add64(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::AddDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.addDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.addDouble(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.addDouble(args[0].asAddress(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.addDouble(args[0].asBaseIndex(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.addDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.addDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AddFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.addFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.addFloat(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.addFloat(args[0].asAddress(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.addFloat(args[0].asBaseIndex(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.addFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.addFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Sub32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.sub32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.sub32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.sub32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.sub32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.sub32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Tmp:
jit.sub32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.sub32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.sub32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.sub32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.sub32(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Sub64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.sub64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.sub64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.sub64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.sub64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.sub64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.sub64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.sub64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.sub64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
jit.sub64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
if (isARM64()) {
jit.sub64(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 6:
#if CPU(X86) || CPU(ARM_THUMB2)
if (isX86() || isARM_THUMB2()) {
jit.sub64(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::SubDouble:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64) || CPU(X86_64)
if (isARM_THUMB2() || isARM64() || isX86_64_AVX()) {
jit.subDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.subDouble(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.subDouble(args[0].fpr(), args[1].asBaseIndex(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.subDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.subDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SubFloat:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64) || CPU(X86_64)
if (isARM_THUMB2() || isARM64() || isX86_64_AVX()) {
jit.subFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.subFloat(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.subFloat(args[0].fpr(), args[1].asBaseIndex(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.subFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.subFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Neg32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.neg32(args[0].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.neg32(args[0].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.neg32(args[0].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::Neg64:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.neg64(args[0].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.neg64(args[0].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.neg64(args[0].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::NegateDouble:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.negateDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::NegateFloat:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.negateFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::Mul32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.mul32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.mul32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.mul32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.mul32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.mul32(args[0].asAddress(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.mul32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::UMull32:
#if CPU(X86) || CPU(ARM_THUMB2)
if (isX86() || isARM_THUMB2()) {
jit.uMull32(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::Mul64:
switch (this->args.size()) {
case 2:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.mul64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 3:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.mul64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::MultiplyAdd32:
#if CPU(ARM64)
if (isARM64()) {
jit.multiplyAdd32(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MultiplyAdd64:
#if CPU(ARM64)
if (isARM64()) {
jit.multiplyAdd64(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MultiplyAddSignExtend32:
#if CPU(ARM64)
if (isARM64()) {
jit.multiplyAddSignExtend32(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MultiplyAddZeroExtend32:
#if CPU(ARM64)
if (isARM64()) {
jit.multiplyAddZeroExtend32(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MultiplySub32:
#if CPU(ARM64)
if (isARM64()) {
jit.multiplySub32(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MultiplySub64:
#if CPU(ARM64)
if (isARM64()) {
jit.multiplySub64(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MultiplySubSignExtend32:
#if CPU(ARM64)
if (isARM64()) {
jit.multiplySubSignExtend32(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MultiplySubZeroExtend32:
#if CPU(ARM64)
if (isARM64()) {
jit.multiplySubZeroExtend32(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MultiplyNeg32:
#if CPU(ARM64)
if (isARM64()) {
jit.multiplyNeg32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MultiplyNeg64:
#if CPU(ARM64)
if (isARM64()) {
jit.multiplyNeg64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MultiplyNegSignExtend32:
#if CPU(ARM64)
if (isARM64()) {
jit.multiplyNegSignExtend32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MultiplyNegZeroExtend32:
#if CPU(ARM64)
if (isARM64()) {
jit.multiplyNegZeroExtend32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MultiplySignExtend32:
#if CPU(ARM64)
if (isARM64()) {
jit.multiplySignExtend32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MultiplyZeroExtend32:
#if CPU(ARM64)
if (isARM64()) {
jit.multiplyZeroExtend32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MulHigh32:
#if CPU(ARM64)
if (isARM64()) {
jit.mulHigh32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::UMulHigh32:
#if CPU(ARM64)
if (isARM64()) {
jit.uMulHigh32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MulHigh64:
#if CPU(ARM64)
if (isARM64()) {
jit.mulHigh64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::UMulHigh64:
#if CPU(ARM64)
if (isARM64()) {
jit.uMulHigh64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::X86MulHigh32:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.x86MulHigh32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::X86UMulHigh32:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.x86UMulHigh32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::X86MulHigh64:
#if CPU(X86_64)
if (isX86_64()) {
jit.x86MulHigh64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::X86UMulHigh64:
#if CPU(X86_64)
if (isX86_64()) {
jit.x86UMulHigh64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::Div32:
#if CPU(ARM64)
if (isARM64()) {
jit.div32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::UDiv32:
#if CPU(ARM64)
if (isARM64()) {
jit.uDiv32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::Div64:
#if CPU(ARM64)
if (isARM64()) {
jit.div64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::UDiv64:
#if CPU(ARM64)
if (isARM64()) {
jit.uDiv64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MulDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.mulDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.mulDouble(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.mulDouble(args[0].asAddress(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.mulDouble(args[0].asBaseIndex(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.mulDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.mulDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MulFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.mulFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.mulFloat(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.mulFloat(args[0].asAddress(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.mulFloat(args[0].asBaseIndex(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.mulFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.mulFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplyNegDouble:
#if CPU(ARM64)
if (isARM64()) {
jit.multiplyNegDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MultiplyNegFloat:
#if CPU(ARM64)
if (isARM64()) {
jit.multiplyNegFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::DivDouble:
switch (this->args.size()) {
case 3:
#if CPU(ARM_THUMB2) || CPU(ARM64) || CPU(X86_64)
if (isARM_THUMB2() || isARM64() || isX86_64_AVX()) {
jit.divDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.divDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.divDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::DivFloat:
switch (this->args.size()) {
case 3:
#if CPU(ARM_THUMB2) || CPU(ARM64) || CPU(X86_64)
if (isARM_THUMB2() || isARM64() || isX86_64_AVX()) {
jit.divFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.divFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.divFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86ConvertToDoubleWord32:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.x86ConvertToDoubleWord32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::X86ConvertToQuadWord64:
#if CPU(X86_64)
if (isX86_64()) {
jit.x86ConvertToQuadWord64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::X86Div32:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.x86Div32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::X86UDiv32:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.x86UDiv32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::X86Div64:
#if CPU(X86_64)
if (isX86_64()) {
jit.x86Div64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::X86UDiv64:
#if CPU(X86_64)
if (isX86_64()) {
jit.x86UDiv64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::Lea32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.lea32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.x86Lea32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::Lea64:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.lea64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.x86Lea64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::And32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.and32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.and32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::BitImm:
#if CPU(ARM64)
if (isARM64()) {
jit.and32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(ARM_THUMB2)
if (isX86() || isARM_THUMB2()) {
jit.and32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.and32(args[0].asAddress(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.and32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.and32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.and32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.and32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.and32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.and32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.and32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.and32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::And64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.and64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
#if CPU(ARM64)
if (isARM64()) {
jit.and64(args[0].asTrustedImm64(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
jit.and64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.and64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.and64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
jit.and64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.and64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.and64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.and64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.and64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AndDouble:
switch (this->args.size()) {
case 3:
jit.andDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.andDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::AndFloat:
switch (this->args.size()) {
case 3:
jit.andFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.andFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::OrDouble:
switch (this->args.size()) {
case 3:
jit.orDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.orDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::OrFloat:
switch (this->args.size()) {
case 3:
jit.orFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.orFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::XorDouble:
switch (this->args.size()) {
case 3:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.xorDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.xorDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::XorFloat:
switch (this->args.size()) {
case 3:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.xorFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.xorFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::Lshift32:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.lshift32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.lshift32(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.lshift32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.lshift32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Lshift64:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
jit.lshift64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
if (isARM64()) {
jit.lshift64(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
jit.lshift64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
if (isX86_64()) {
jit.lshift64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Rshift32:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.rshift32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.rshift32(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.rshift32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.rshift32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Rshift64:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
jit.rshift64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
if (isARM64()) {
jit.rshift64(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
jit.rshift64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
if (isX86_64()) {
jit.rshift64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Urshift32:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.urshift32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.urshift32(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.urshift32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.urshift32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Urshift64:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
jit.urshift64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
if (isARM64()) {
jit.urshift64(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
jit.urshift64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
if (isX86_64()) {
jit.urshift64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RotateRight32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
jit.rotateRight32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
if (isX86_64()) {
jit.rotateRight32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.rotateRight32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.rotateRight32(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RotateRight64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
jit.rotateRight64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
if (isX86_64()) {
jit.rotateRight64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
jit.rotateRight64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
if (isARM64()) {
jit.rotateRight64(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RotateLeft32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
jit.rotateLeft32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
if (isX86_64()) {
jit.rotateLeft32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM_THUMB2)
if (isARM_THUMB2()) {
jit.rotateLeft32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM_THUMB2)
if (isARM_THUMB2()) {
jit.rotateLeft32(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RotateLeft64:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
jit.rotateLeft64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
if (isX86_64()) {
jit.rotateLeft64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::Or32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.or32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.or32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::BitImm:
#if CPU(ARM64)
if (isARM64()) {
jit.or32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.or32(args[0].asAddress(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.or32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.or32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.or32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.or32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.or32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.or32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.or32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.or32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Or64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.or64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
#if CPU(ARM64)
if (isARM64()) {
jit.or64(args[0].asTrustedImm64(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.or64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.or64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.or64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
jit.or64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.or64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.or64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.or64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.or64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xor32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.xor32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.xor32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::BitImm:
#if CPU(ARM64)
if (isARM64()) {
jit.xor32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.xor32(args[0].asAddress(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM_THUMB2)
if (isARM_THUMB2()) {
jit.xor32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.xor32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.xor32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.xor32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.xor32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.xor32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.xor32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.xor32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.xor32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xor64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.xor64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
#if CPU(ARM64)
if (isARM64()) {
jit.xor64(args[0].asTrustedImm64(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.xor64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.xor64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.xor64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.xor64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.xor64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.xor64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.xor64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
jit.xor64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Not32:
switch (this->args.size()) {
case 2:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.not32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.not32(args[0].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.not32(args[0].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.not32(args[0].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Not64:
switch (this->args.size()) {
case 2:
#if CPU(ARM64)
if (isARM64()) {
jit.not64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
jit.not64(args[0].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.not64(args[0].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.not64(args[0].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AbsDouble:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.absDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AbsFloat:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.absFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::CeilDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.ceilDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.ceilDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::CeilFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.ceilFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.ceilFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::FloorDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.floorDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.floorDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::FloorFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.floorFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.floorFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::TruncDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.truncDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.truncDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::TruncFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.truncFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.truncFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::SqrtDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.sqrtDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.sqrtDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::SqrtFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.sqrtFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.sqrtFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::ConvertInt32ToDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.convertInt32ToDouble(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.convertInt32ToDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::ConvertInt64ToDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.convertInt64ToDouble(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.convertInt64ToDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::ConvertInt32ToFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.convertInt32ToFloat(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.convertInt32ToFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::ConvertInt64ToFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.convertInt64ToFloat(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.convertInt64ToFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::ConvertUInt32ToDouble:
#if CPU(ARM64)
if (isARM64()) {
jit.convertUInt32ToDouble(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::ConvertUInt32ToFloat:
#if CPU(ARM64)
if (isARM64()) {
jit.convertUInt32ToFloat(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::CountLeadingZeros32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.countLeadingZeros32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.countLeadingZeros32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::CountLeadingZeros64:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.countLeadingZeros64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.countLeadingZeros64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::ConvertDoubleToFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.convertDoubleToFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.convertDoubleToFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::ConvertFloatToDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.convertFloatToDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.convertFloatToDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::Move:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.move(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.storePtr(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.storePtr(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.signExtend32ToPtr(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.storePtr(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::BigImm:
jit.move(args[0].asTrustedBigImm(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.loadPtr(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.loadPtr(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::ZeroReg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
jit.move(args[0].asZeroReg(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(ARM64)
if (isARM64()) {
jit.storePtr(args[0].asZeroReg(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(ARM64)
if (isARM64()) {
jit.storePtr(args[0].asZeroReg(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
jit.move(args[0].asAddress(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::Swap32:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.swap32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.swap32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::Swap64:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
jit.swap64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.swap64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveWithIncrement64:
switch (this->args[0].kind()) {
case Arg::PreIndex:
#if CPU(ARM64)
if (isARM64()) {
jit.load64(args[0].asPreIndexAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::PostIndex:
#if CPU(ARM64)
if (isARM64()) {
jit.load64(args[0].asPostIndexAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::PreIndex:
#if CPU(ARM64)
if (isARM64()) {
jit.store64(args[0].gpr(), args[1].asPreIndexAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::PostIndex:
#if CPU(ARM64)
if (isARM64()) {
jit.store64(args[0].gpr(), args[1].asPostIndexAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Move32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.zeroExtend32ToWord(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.store32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.store32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.zeroExtend32ToWord(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64) || CPU(ARM_THUMB2)
if (isX86() || isX86_64() || isARM_THUMB2()) {
jit.store32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.store32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::ZeroReg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
jit.move(args[0].asZeroReg(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(ARM64)
if (isARM64()) {
jit.store32(args[0].asZeroReg(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(ARM64)
if (isARM64()) {
jit.store32(args[0].asZeroReg(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
jit.move32(args[0].asAddress(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::MoveWithIncrement32:
switch (this->args[0].kind()) {
case Arg::PreIndex:
#if CPU(ARM64)
if (isARM64()) {
jit.load32(args[0].asPreIndexAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::PostIndex:
#if CPU(ARM64)
if (isARM64()) {
jit.load32(args[0].asPostIndexAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::PreIndex:
#if CPU(ARM64)
if (isARM64()) {
jit.store32(args[0].gpr(), args[1].asPreIndexAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::PostIndex:
#if CPU(ARM64)
if (isARM64()) {
jit.store32(args[0].gpr(), args[1].asPostIndexAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadPair32:
#if CPU(ARM64)
if (isARM64()) {
jit.loadPair32(args[0].asAddress(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::LoadPair64:
#if CPU(ARM64)
if (isARM64()) {
jit.loadPair64(args[0].asAddress(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::StorePair32:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
jit.storePair32(args[0].gpr(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::ZeroReg:
#if CPU(ARM64)
if (isARM64()) {
jit.storePair32(args[0].gpr(), args[1].asZeroReg(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::ZeroReg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
jit.storePair32(args[0].asZeroReg(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::ZeroReg:
#if CPU(ARM64)
if (isARM64()) {
jit.storePair32(args[0].asZeroReg(), args[1].asZeroReg(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StorePair64:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
jit.storePair64(args[0].gpr(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::ZeroReg:
#if CPU(ARM64)
if (isARM64()) {
jit.storePair64(args[0].gpr(), args[1].asZeroReg(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::ZeroReg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
jit.storePair64(args[0].asZeroReg(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::ZeroReg:
#if CPU(ARM64)
if (isARM64()) {
jit.storePair64(args[0].asZeroReg(), args[1].asZeroReg(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SignExtend8To64:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.signExtend8To64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::SignExtend16To64:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.signExtend16To64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::SignExtend32To64:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.signExtend32To64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::ZeroExtend8To32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.zeroExtend8To32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.load8(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.load8(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::SignExtend8To32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.signExtend8To32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.load8SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.load8SignedExtendTo32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::ZeroExtend16To32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.zeroExtend16To32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.load16(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.load16(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::SignExtend16To32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.signExtend16To32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.load16SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.load16SignedExtendTo32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.moveDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.storeFloat(args[0].fpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.storeFloat(args[0].fpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.loadFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.loadFloat(args[0].asBaseIndex(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case 3:
jit.moveFloat(args[0].asAddress(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::MoveDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.moveDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.storeDouble(args[0].fpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.storeDouble(args[0].fpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.loadDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.loadDouble(args[0].asBaseIndex(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case 3:
jit.moveDouble(args[0].asAddress(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::LoadPairFloat:
#if CPU(ARM64)
if (isARM64()) {
jit.loadPairFloat(args[0].asAddress(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::LoadPairDouble:
#if CPU(ARM64)
if (isARM64()) {
jit.loadPairDouble(args[0].asAddress(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::StorePairFloat:
#if CPU(ARM64)
if (isARM64()) {
jit.storePairFloat(args[0].fpr(), args[1].fpr(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::StorePairDouble:
#if CPU(ARM64)
if (isARM64()) {
jit.storePairDouble(args[0].fpr(), args[1].fpr(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MoveVector:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.moveVector(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.storeVector(args[0].fpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.storeVector(args[0].fpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.loadVector(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.loadVector(args[0].asBaseIndex(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.moveVector(args[0].asAddress(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveZeroToDouble:
jit.moveZeroToDouble(args[0].fpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::MoveZeroToFloat:
jit.moveZeroToFloat(args[0].fpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::Move64ToDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.move64ToDouble(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.loadDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::FPImm64:
#if CPU(ARM64)
if (isARM64()) {
jit.move64ToDouble(args[0].asTrustedImm64(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.loadDouble(args[0].asBaseIndex(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
#if CPU(X86) || CPU(ARM_THUMB2)
if (isX86() || isARM_THUMB2()) {
jit.move64ToDouble(args[0].gpr(), args[1].gpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::Move32ToDoubleHi:
#if CPU(X86) || CPU(ARM_THUMB2)
if (isX86() || isARM_THUMB2()) {
jit.move32ToDoubleHi(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::Move32ToFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.move32ToFloat(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.loadFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::FPImm32:
#if CPU(ARM64)
if (isARM64()) {
jit.move32ToFloat(args[0].asTrustedImm32(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
jit.loadFloat(args[0].asBaseIndex(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::MoveDoubleTo64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.moveDoubleTo64(args[0].fpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.load64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.load64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
#if CPU(X86) || CPU(ARM_THUMB2)
if (isX86() || isARM_THUMB2()) {
jit.moveDoubleTo64(args[0].fpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveDoubleHiTo32:
#if CPU(X86) || CPU(ARM_THUMB2)
if (isX86() || isARM_THUMB2()) {
jit.moveDoubleHiTo32(args[0].fpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MoveFloatTo32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.moveFloatTo32(args[0].fpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::Load8:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load8(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load8(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::LoadAcq8:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.loadAcq8(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::Store8:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Index:
jit.store8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.store8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.store8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.store8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::ZeroReg:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(ARM64)
if (isARM64()) {
jit.store8(args[0].asZeroReg(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(ARM64)
if (isARM64()) {
jit.store8(args[0].asZeroReg(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel8:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.storeRel8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::Load8SignedExtendTo32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load8SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load8SignedExtendTo32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::LoadAcq8SignedExtendTo32:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.loadAcq8SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::Load16:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load16(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load16(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::LoadAcq16:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.loadAcq16(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::Load16SignedExtendTo32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load16SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load16SignedExtendTo32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::LoadAcq16SignedExtendTo32:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.loadAcq16SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::Store16:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Index:
jit.store16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.store16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.store16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.store16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::ZeroReg:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(ARM64)
if (isARM64()) {
jit.store16(args[0].asZeroReg(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(ARM64)
if (isARM64()) {
jit.store16(args[0].asZeroReg(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel16:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.storeRel16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::LoadAcq32:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.loadAcq32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::StoreRel32:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.storeRel32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::LoadAcq64:
#if CPU(ARM64)
if (isARM64()) {
jit.loadAcq64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::StoreRel64:
#if CPU(ARM64)
if (isARM64()) {
jit.storeRel64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::Xchg8:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.xchg8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.xchg8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::Xchg16:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.xchg16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.xchg16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::Xchg32:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.xchg32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.xchg32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::Xchg64:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.xchg64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.xchg64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::ExtractUnsignedBitfield32:
#if CPU(ARM64)
if (isARM64()) {
jit.extractUnsignedBitfield32(args[0].gpr(), args[1].asTrustedImm32(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::ExtractUnsignedBitfield64:
#if CPU(ARM64)
if (isARM64()) {
jit.extractUnsignedBitfield64(args[0].gpr(), args[1].asTrustedImm32(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::InsertUnsignedBitfieldInZero32:
#if CPU(ARM64)
if (isARM64()) {
jit.insertUnsignedBitfieldInZero32(args[0].gpr(), args[1].asTrustedImm32(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::InsertUnsignedBitfieldInZero64:
#if CPU(ARM64)
if (isARM64()) {
jit.insertUnsignedBitfieldInZero64(args[0].gpr(), args[1].asTrustedImm32(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::InsertBitField32:
#if CPU(ARM64)
if (isARM64()) {
jit.insertBitField32(args[0].gpr(), args[1].asTrustedImm32(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::InsertBitField64:
#if CPU(ARM64)
if (isARM64()) {
jit.insertBitField64(args[0].gpr(), args[1].asTrustedImm32(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::ClearBitField32:
#if CPU(ARM64)
if (isARM64()) {
jit.clearBitField32(args[0].asTrustedImm32(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::ClearBitField64:
#if CPU(ARM64)
if (isARM64()) {
jit.clearBitField64(args[0].asTrustedImm32(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::ClearBitsWithMask32:
#if CPU(ARM64)
if (isARM64()) {
jit.clearBitsWithMask32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::ClearBitsWithMask64:
#if CPU(ARM64)
if (isARM64()) {
jit.clearBitsWithMask64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::ReverseBits64:
#if CPU(ARM64)
if (isARM64()) {
jit.reverseBits64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::ReverseBits32:
#if CPU(ARM64)
if (isARM64()) {
jit.reverseBits32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::OrNot32:
#if CPU(ARM64)
if (isARM64()) {
jit.orNot32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::OrNot64:
#if CPU(ARM64)
if (isARM64()) {
jit.orNot64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::XorNot32:
#if CPU(ARM64)
if (isARM64()) {
jit.xorNot32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::XorNot64:
#if CPU(ARM64)
if (isARM64()) {
jit.xorNot64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::XorNotLeftShift32:
#if CPU(ARM64)
if (isARM64()) {
jit.xorNotLeftShift32(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::XorNotRightShift32:
#if CPU(ARM64)
if (isARM64()) {
jit.xorNotRightShift32(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::XorNotUnsignedRightShift32:
#if CPU(ARM64)
if (isARM64()) {
jit.xorNotUnsignedRightShift32(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::XorNotLeftShift64:
#if CPU(ARM64)
if (isARM64()) {
jit.xorNotLeftShift64(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::XorNotRightShift64:
#if CPU(ARM64)
if (isARM64()) {
jit.xorNotRightShift64(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::XorNotUnsignedRightShift64:
#if CPU(ARM64)
if (isARM64()) {
jit.xorNotUnsignedRightShift64(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::ExtractInsertBitfieldAtLowEnd32:
#if CPU(ARM64)
if (isARM64()) {
jit.extractInsertBitfieldAtLowEnd32(args[0].gpr(), args[1].asTrustedImm32(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::ExtractInsertBitfieldAtLowEnd64:
#if CPU(ARM64)
if (isARM64()) {
jit.extractInsertBitfieldAtLowEnd64(args[0].gpr(), args[1].asTrustedImm32(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::InsertSignedBitfieldInZero32:
#if CPU(ARM64)
if (isARM64()) {
jit.insertSignedBitfieldInZero32(args[0].gpr(), args[1].asTrustedImm32(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::InsertSignedBitfieldInZero64:
#if CPU(ARM64)
if (isARM64()) {
jit.insertSignedBitfieldInZero64(args[0].gpr(), args[1].asTrustedImm32(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::ExtractSignedBitfield32:
#if CPU(ARM64)
if (isARM64()) {
jit.extractSignedBitfield32(args[0].gpr(), args[1].asTrustedImm32(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::ExtractSignedBitfield64:
#if CPU(ARM64)
if (isARM64()) {
jit.extractSignedBitfield64(args[0].gpr(), args[1].asTrustedImm32(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::ExtractRegister32:
#if CPU(ARM64)
if (isARM64()) {
jit.extractRegister32(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::ExtractRegister64:
#if CPU(ARM64)
if (isARM64()) {
jit.extractRegister64(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AddLeftShift32:
#if CPU(ARM64)
if (isARM64()) {
jit.addLeftShift32(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AddRightShift32:
#if CPU(ARM64)
if (isARM64()) {
jit.addRightShift32(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AddUnsignedRightShift32:
#if CPU(ARM64)
if (isARM64()) {
jit.addUnsignedRightShift32(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AddLeftShift64:
#if CPU(ARM64)
if (isARM64()) {
jit.addLeftShift64(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AddRightShift64:
#if CPU(ARM64)
if (isARM64()) {
jit.addRightShift64(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AddUnsignedRightShift64:
#if CPU(ARM64)
if (isARM64()) {
jit.addUnsignedRightShift64(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::SubLeftShift32:
#if CPU(ARM64)
if (isARM64()) {
jit.subLeftShift32(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::SubRightShift32:
#if CPU(ARM64)
if (isARM64()) {
jit.subRightShift32(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::SubUnsignedRightShift32:
#if CPU(ARM64)
if (isARM64()) {
jit.subUnsignedRightShift32(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::SubLeftShift64:
#if CPU(ARM64)
if (isARM64()) {
jit.subLeftShift64(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::SubRightShift64:
#if CPU(ARM64)
if (isARM64()) {
jit.subRightShift64(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::SubUnsignedRightShift64:
#if CPU(ARM64)
if (isARM64()) {
jit.subUnsignedRightShift64(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AndLeftShift32:
#if CPU(ARM64)
if (isARM64()) {
jit.andLeftShift32(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AndRightShift32:
#if CPU(ARM64)
if (isARM64()) {
jit.andRightShift32(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AndUnsignedRightShift32:
#if CPU(ARM64)
if (isARM64()) {
jit.andUnsignedRightShift32(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AndLeftShift64:
#if CPU(ARM64)
if (isARM64()) {
jit.andLeftShift64(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AndRightShift64:
#if CPU(ARM64)
if (isARM64()) {
jit.andRightShift64(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AndUnsignedRightShift64:
#if CPU(ARM64)
if (isARM64()) {
jit.andUnsignedRightShift64(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::XorLeftShift32:
#if CPU(ARM64)
if (isARM64()) {
jit.xorLeftShift32(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::XorRightShift32:
#if CPU(ARM64)
if (isARM64()) {
jit.xorRightShift32(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::XorUnsignedRightShift32:
#if CPU(ARM64)
if (isARM64()) {
jit.xorUnsignedRightShift32(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::XorLeftShift64:
#if CPU(ARM64)
if (isARM64()) {
jit.xorLeftShift64(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::XorRightShift64:
#if CPU(ARM64)
if (isARM64()) {
jit.xorRightShift64(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::XorUnsignedRightShift64:
#if CPU(ARM64)
if (isARM64()) {
jit.xorUnsignedRightShift64(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::OrLeftShift32:
#if CPU(ARM64)
if (isARM64()) {
jit.orLeftShift32(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::OrRightShift32:
#if CPU(ARM64)
if (isARM64()) {
jit.orRightShift32(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::OrUnsignedRightShift32:
#if CPU(ARM64)
if (isARM64()) {
jit.orUnsignedRightShift32(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::OrLeftShift64:
#if CPU(ARM64)
if (isARM64()) {
jit.orLeftShift64(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::OrRightShift64:
#if CPU(ARM64)
if (isARM64()) {
jit.orRightShift64(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::OrUnsignedRightShift64:
#if CPU(ARM64)
if (isARM64()) {
jit.orUnsignedRightShift64(args[0].gpr(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::FloatMax:
#if CPU(ARM64)
if (isARM64()) {
jit.floatMax(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::FloatMin:
#if CPU(ARM64)
if (isARM64()) {
jit.floatMin(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::DoubleMax:
#if CPU(ARM64)
if (isARM64()) {
jit.doubleMax(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::DoubleMin:
#if CPU(ARM64)
if (isARM64()) {
jit.doubleMin(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AtomicStrongCAS8:
switch (this->args.size()) {
case 5:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicStrongCAS8(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress(), args[4].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicStrongCAS8(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex(), args[4].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicStrongCAS8(args[0].gpr(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicStrongCAS8(args[0].gpr(), args[1].gpr(), args[2].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::SimpleAddr:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicStrongCAS8(args[0].gpr(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS16:
switch (this->args.size()) {
case 5:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicStrongCAS16(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress(), args[4].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicStrongCAS16(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex(), args[4].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicStrongCAS16(args[0].gpr(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicStrongCAS16(args[0].gpr(), args[1].gpr(), args[2].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::SimpleAddr:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicStrongCAS16(args[0].gpr(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS32:
switch (this->args.size()) {
case 5:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicStrongCAS32(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress(), args[4].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicStrongCAS32(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex(), args[4].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicStrongCAS32(args[0].gpr(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicStrongCAS32(args[0].gpr(), args[1].gpr(), args[2].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::SimpleAddr:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicStrongCAS32(args[0].gpr(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS64:
switch (this->args.size()) {
case 5:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicStrongCAS64(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress(), args[4].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicStrongCAS64(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex(), args[4].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicStrongCAS64(args[0].gpr(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicStrongCAS64(args[0].gpr(), args[1].gpr(), args[2].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::SimpleAddr:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicStrongCAS64(args[0].gpr(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS8:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchAtomicStrongCAS8(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchAtomicStrongCAS8(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS16:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchAtomicStrongCAS16(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchAtomicStrongCAS16(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS32:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchAtomicStrongCAS32(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchAtomicStrongCAS32(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS64:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
result = jit.branchAtomicStrongCAS64(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
result = jit.branchAtomicStrongCAS64(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicAdd8:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAdd8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAdd8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAdd8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAdd8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd16:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAdd16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAdd16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAdd16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAdd16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd32:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAdd32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAdd32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAdd32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAdd32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd64:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicAdd64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicAdd64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicAdd64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicAdd64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub8:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicSub8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicSub8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicSub8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicSub8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub16:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicSub16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicSub16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicSub16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicSub16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub32:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicSub32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicSub32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicSub32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicSub32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub64:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicSub64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicSub64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicSub64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicSub64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd8:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAnd8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAnd8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAnd8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAnd8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd16:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAnd16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAnd16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAnd16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAnd16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd32:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAnd32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAnd32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAnd32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicAnd32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd64:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicAnd64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicAnd64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicAnd64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicAnd64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr8:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicOr8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicOr8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicOr8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicOr8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr16:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicOr16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicOr16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicOr16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicOr16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr32:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicOr32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicOr32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicOr32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicOr32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr64:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicOr64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicOr64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicOr64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicOr64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor8:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXor8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXor8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXor8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXor8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor16:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXor16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXor16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXor16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXor16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor32:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXor32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXor32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXor32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXor32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor64:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicXor64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicXor64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicXor64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicXor64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg8:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicNeg8(args[0].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicNeg8(args[0].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicNeg16:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicNeg16(args[0].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicNeg16(args[0].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicNeg32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicNeg32(args[0].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicNeg32(args[0].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicNeg64:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicNeg64(args[0].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicNeg64(args[0].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicNot8:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicNot8(args[0].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicNot8(args[0].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicNot16:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicNot16(args[0].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicNot16(args[0].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicNot32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicNot32(args[0].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicNot32(args[0].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicNot64:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicNot64(args[0].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicNot64(args[0].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd8:
switch (this->args.size()) {
case 2:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXchgAdd8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXchgAdd8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicXchgAdd8(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd16:
switch (this->args.size()) {
case 2:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXchgAdd16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXchgAdd16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicXchgAdd16(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd32:
switch (this->args.size()) {
case 2:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXchgAdd32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXchgAdd32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicXchgAdd32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd64:
switch (this->args.size()) {
case 2:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicXchgAdd64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicXchgAdd64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicXchgAdd64(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchg8:
switch (this->args.size()) {
case 2:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXchg8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXchg8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicXchg8(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchg16:
switch (this->args.size()) {
case 2:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXchg16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXchg16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicXchg16(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchg32:
switch (this->args.size()) {
case 2:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXchg32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.atomicXchg32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicXchg32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchg64:
switch (this->args.size()) {
case 2:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicXchg64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.atomicXchg64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicXchg64(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::LoadLink8:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.loadLink8(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::LoadLinkAcq8:
#if CPU(ARM64)
if (isARM64()) {
jit.loadLinkAcq8(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::StoreCond8:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.storeCond8(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::StoreCondRel8:
#if CPU(ARM64)
if (isARM64()) {
jit.storeCondRel8(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::LoadLink16:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.loadLink16(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::LoadLinkAcq16:
#if CPU(ARM64)
if (isARM64()) {
jit.loadLinkAcq16(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::StoreCond16:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.storeCond16(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::StoreCondRel16:
#if CPU(ARM64)
if (isARM64()) {
jit.storeCondRel16(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::LoadLink32:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.loadLink32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::LoadLinkAcq32:
#if CPU(ARM64)
if (isARM64()) {
jit.loadLinkAcq32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::StoreCond32:
#if CPU(ARM_THUMB2) || CPU(ARM64)
if (isARM_THUMB2() || isARM64()) {
jit.storeCond32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::StoreCondRel32:
#if CPU(ARM64)
if (isARM64()) {
jit.storeCondRel32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::LoadLinkPair32:
#if CPU(ARM_THUMB2)
if (isARM_THUMB2()) {
jit.loadLinkPair32(args[0].asAddress(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::LoadLink64:
#if CPU(ARM64)
if (isARM64()) {
jit.loadLink64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::LoadLinkAcq64:
#if CPU(ARM64)
if (isARM64()) {
jit.loadLinkAcq64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::StoreCondPair32:
#if CPU(ARM_THUMB2)
if (isARM_THUMB2()) {
jit.storeCondPair32(args[0].gpr(), args[1].gpr(), args[2].asAddress(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::StoreCond64:
#if CPU(ARM64)
if (isARM64()) {
jit.storeCond64(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::StoreCondRel64:
#if CPU(ARM64)
if (isARM64()) {
jit.storeCondRel64(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::Depend32:
#if CPU(ARM_THUMB2) || CPU(ARM64) || CPU(ARM64)
if (isARM_THUMB2() || isARM64() || isARM64()) {
jit.depend32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::Depend64:
#if CPU(ARM64)
if (isARM64()) {
jit.depend64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AtomicXchgOr8:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicXchgOr8(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AtomicXchgOr16:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicXchgOr16(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AtomicXchgOr32:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicXchgOr32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AtomicXchgOr64:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicXchgOr64(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AtomicXchgClear8:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicXchgClear8(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AtomicXchgClear16:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicXchgClear16(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AtomicXchgClear32:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicXchgClear32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AtomicXchgClear64:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicXchgClear64(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AtomicXchgXor8:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicXchgXor8(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AtomicXchgXor16:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicXchgXor16(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AtomicXchgXor32:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicXchgXor32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::AtomicXchgXor64:
#if CPU(ARM64)
if (isARM64_LSE()) {
jit.atomicXchgXor64(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::Compare32:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.compare32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
jit.compare32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::Compare64:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.compare64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.compare64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::Test32:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
jit.test32(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.test32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::BitImm:
jit.test32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Test64:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64)
if (isX86_64()) {
jit.test64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.test64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::CompareDouble:
jit.compareDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::CompareFloat:
jit.compareFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::CompareDoubleWithZero:
#if CPU(ARM64)
if (isARM64()) {
jit.compareDoubleWithZero(args[0].asDoubleCondition(), args[1].fpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::CompareFloatWithZero:
#if CPU(ARM64)
if (isARM64()) {
jit.compareFloatWithZero(args[0].asDoubleCondition(), args[1].fpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::Branch8:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branch8(args[0].asRelationalCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branch8(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::Branch32:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branch32(args[0].asRelationalCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branch32(args[0].asRelationalCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branch32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
result = jit.branch32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branch32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branch32(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::Branch64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
result = jit.branch64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
result = jit.branch64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
result = jit.branch64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
result = jit.branch64(args[0].asRelationalCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
if (isX86_64()) {
result = jit.branch64(args[0].asRelationalCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
result = jit.branch64(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchTest8:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchTest8(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchTest8(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchTest32:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchTest32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::BitImm:
result = jit.branchTest32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(ARM_THUMB2)
if (isX86() || isARM_THUMB2()) {
result = jit.branchTest32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchTest32(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchTest32(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchTest64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
result = jit.branchTest64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
#if CPU(ARM64)
if (isARM64()) {
result = jit.branchTest64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm64());
OPGEN_RETURN(result);
}
#endif
break;
break;
#endif // USE(JSVALUE64)
case Arg::BitImm:
#if CPU(X86_64)
if (isX86_64()) {
result = jit.branchTest64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::BitImm:
#if CPU(X86_64)
if (isX86_64()) {
result = jit.branchTest64(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
result = jit.branchTest64(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
result = jit.branchTest64(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchTestBit64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64)
if (isX86_64()) {
result = jit.branchTestBit64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
result = jit.branchTestBit64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
result = jit.branchTestBit64(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchTestBit32:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchTestBit32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchTestBit32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchTestBit32(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchDouble:
result = jit.branchDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::BranchFloat:
result = jit.branchFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::BranchDoubleWithZero:
#if CPU(ARM64)
if (isARM64()) {
result = jit.branchDoubleWithZero(args[0].asDoubleCondition(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::BranchFloatWithZero:
#if CPU(ARM64)
if (isARM64()) {
result = jit.branchFloatWithZero(args[0].asDoubleCondition(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::BranchAdd32:
switch (this->args.size()) {
case 4:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchAdd32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
#if CPU(ARM64)
if (isARM64()) {
result = jit.branchAdd32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchAdd32(args[0].asResultCondition(), args[1].gpr(), args[2].asAddress(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchAdd32(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchAdd32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchAdd32(args[0].asResultCondition(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchAdd32(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchAdd32(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchAdd32(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAdd64:
switch (this->args.size()) {
case 4:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
result = jit.branchAdd64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
if (isARM64()) {
result = jit.branchAdd64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
result = jit.branchAdd64(args[0].asResultCondition(), args[1].gpr(), args[2].asAddress(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
result = jit.branchAdd64(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[1].kind()) {
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
result = jit.branchAdd64(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
result = jit.branchAdd64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
result = jit.branchAdd64(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchMul32:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchMul32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchMul32(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 4:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchMul32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
result = jit.branchMul32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchMul64:
switch (this->args.size()) {
case 3:
#if CPU(X86_64)
if (isX86_64()) {
result = jit.branchMul64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 5:
#if CPU(ARM64)
if (isARM64()) {
result = jit.branchMul64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchSub32:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchSub32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchSub32(args[0].asResultCondition(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchSub32(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchSub32(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].asAddress());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (isX86() || isX86_64()) {
result = jit.branchSub32(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 4:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
result = jit.branchSub32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
if (isARM64()) {
result = jit.branchSub32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchSub64:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
result = jit.branchSub64(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
result = jit.branchSub64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 4:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (isARM64()) {
result = jit.branchSub64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
if (isARM64()) {
result = jit.branchSub64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchNeg32:
result = jit.branchNeg32(args[0].asResultCondition(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::BranchNeg64:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
result = jit.branchNeg64(args[0].asResultCondition(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MoveConditionally32:
switch (this->args.size()) {
case 5:
#if CPU(X86_64) || CPU(ARM64) || CPU(ARM_THUMB2)
if (isX86_64() || isARM64() || isARM_THUMB2()) {
jit.moveConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 6:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64) || CPU(ARM_THUMB2)
if (isX86_64() || isARM64() || isARM_THUMB2()) {
jit.moveConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64) || CPU(ARM_THUMB2)
if (isX86_64() || isARM64() || isARM_THUMB2()) {
jit.moveConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionally64:
switch (this->args.size()) {
case 5:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.moveConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 6:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.moveConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.moveConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyTest32:
switch (this->args.size()) {
case 5:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64) || CPU(ARM_THUMB2)
if (isX86_64() || isARM64() || isARM_THUMB2()) {
jit.moveConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
if (isX86_64()) {
jit.moveConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 6:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64) || CPU(ARM_THUMB2)
if (isX86_64() || isARM64() || isARM_THUMB2()) {
jit.moveConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::BitImm:
#if CPU(X86_64) || CPU(ARM64) || CPU(ARM_THUMB2)
if (isX86_64() || isARM64() || isARM_THUMB2()) {
jit.moveConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyTest64:
switch (this->args.size()) {
case 5:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.moveConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
if (isX86_64()) {
jit.moveConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case 6:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.moveConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
if (isX86_64()) {
jit.moveConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyDouble:
switch (this->args.size()) {
case 6:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.moveConditionallyDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 5:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.moveConditionallyDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveConditionallyDoubleWithZero:
switch (this->args.size()) {
case 5:
#if CPU(ARM64)
if (isARM64()) {
jit.moveConditionallyDoubleWithZero(args[0].asDoubleCondition(), args[1].fpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 4:
#if CPU(ARM64)
if (isARM64()) {
jit.moveConditionallyDoubleWithZero(args[0].asDoubleCondition(), args[1].fpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveConditionallyFloat:
switch (this->args.size()) {
case 6:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.moveConditionallyFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 5:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.moveConditionallyFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveConditionallyFloatWithZero:
switch (this->args.size()) {
case 5:
#if CPU(ARM64)
if (isARM64()) {
jit.moveConditionallyFloatWithZero(args[0].asDoubleCondition(), args[1].fpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 4:
#if CPU(ARM64)
if (isARM64()) {
jit.moveConditionallyFloatWithZero(args[0].asDoubleCondition(), args[1].fpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionally32:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64) || CPU(ARM_THUMB2)
if (isX86_64() || isARM64() || isARM_THUMB2()) {
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64) || CPU(ARM_THUMB2)
if (isX86_64() || isARM64() || isARM_THUMB2()) {
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asAddress(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64)
if (isX86_64()) {
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].asAddress(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].asAddress(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionally64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asAddress(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].asAddress(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
if (isX86_64()) {
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].asAddress(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyTest32:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64) || CPU(ARM_THUMB2)
if (isX86_64() || isARM64() || isARM_THUMB2()) {
jit.moveDoubleConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::BitImm:
#if CPU(X86_64) || CPU(ARM64) || CPU(ARM_THUMB2)
if (isX86_64() || isARM64() || isARM_THUMB2()) {
jit.moveDoubleConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (isX86_64()) {
jit.moveDoubleConditionallyTest32(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.moveDoubleConditionallyTest32(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyTest64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.moveDoubleConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
if (isX86_64()) {
jit.moveDoubleConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64)
if (isX86_64()) {
jit.moveDoubleConditionallyTest64(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
if (isX86_64()) {
jit.moveDoubleConditionallyTest64(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86_64)
if (isX86_64()) {
jit.moveDoubleConditionallyTest64(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyDouble:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.moveDoubleConditionallyDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MoveDoubleConditionallyDoubleWithZero:
#if CPU(ARM64)
if (isARM64()) {
jit.moveDoubleConditionallyDoubleWithZero(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].fpr(), args[4].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MoveDoubleConditionallyFloat:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.moveDoubleConditionallyFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MoveDoubleConditionallyFloatWithZero:
#if CPU(ARM64)
if (isARM64()) {
jit.moveDoubleConditionallyFloatWithZero(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].fpr(), args[4].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MemoryFence:
jit.memoryFence();
OPGEN_RETURN(result);
break;
break;
case Opcode::StoreFence:
jit.storeFence();
OPGEN_RETURN(result);
break;
break;
case Opcode::LoadFence:
jit.loadFence();
OPGEN_RETURN(result);
break;
break;
case Opcode::Jump:
result = jit.jump();
OPGEN_RETURN(result);
break;
break;
case Opcode::RetVoid:
jit.retVoid();
OPGEN_RETURN(result);
break;
break;
case Opcode::Ret32:
jit.ret32(args[0].gpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::Ret64:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.ret64(args[0].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::RetFloat:
jit.retFloat(args[0].fpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::RetDouble:
jit.retDouble(args[0].fpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::VectorReplaceLaneInt64:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorReplaceLaneInt64(args[0].asTrustedImm32(), args[1].gpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorReplaceLaneInt32:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorReplaceLaneInt32(args[0].asTrustedImm32(), args[1].gpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorReplaceLaneInt16:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorReplaceLaneInt16(args[0].asTrustedImm32(), args[1].gpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorReplaceLaneInt8:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorReplaceLaneInt8(args[0].asTrustedImm32(), args[1].gpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorReplaceLaneFloat64:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorReplaceLaneFloat64(args[0].asTrustedImm32(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorReplaceLaneFloat32:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorReplaceLaneFloat32(args[0].asTrustedImm32(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorExtractLaneInt64:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorExtractLaneInt64(args[0].asTrustedImm32(), args[1].fpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorExtractLaneInt32:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorExtractLaneInt32(args[0].asTrustedImm32(), args[1].fpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorExtractLaneSignedInt16:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorExtractLaneSignedInt16(args[0].asTrustedImm32(), args[1].fpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorExtractLaneUnsignedInt16:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorExtractLaneUnsignedInt16(args[0].asTrustedImm32(), args[1].fpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorExtractLaneSignedInt8:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorExtractLaneSignedInt8(args[0].asTrustedImm32(), args[1].fpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorExtractLaneUnsignedInt8:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorExtractLaneUnsignedInt8(args[0].asTrustedImm32(), args[1].fpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorExtractLaneFloat64:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorExtractLaneFloat64(args[0].asTrustedImm32(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorExtractLaneFloat32:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorExtractLaneFloat32(args[0].asTrustedImm32(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorSplatInt8:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorSplatInt8(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorSplatInt16:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorSplatInt16(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorSplatInt32:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorSplatInt32(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorSplatInt64:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorSplatInt64(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorSplatFloat32:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorSplatFloat32(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorSplatFloat64:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorSplatFloat64(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::CompareFloatingPointVectorUnordered:
#if CPU(X86_64)
if (isX86_64()) {
jit.compareFloatingPointVectorUnordered(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::CompareFloatingPointVector:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.compareFloatingPointVector(args[0].asDoubleCondition(), args[1].simdInfo(), args[2].fpr(), args[3].fpr(), args[4].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::CompareIntegerVector:
switch (this->args.size()) {
case 5:
#if CPU(ARM64)
if (isARM64()) {
jit.compareIntegerVector(args[0].asRelationalCondition(), args[1].simdInfo(), args[2].fpr(), args[3].fpr(), args[4].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 6:
#if CPU(X86_64)
if (isX86_64()) {
jit.compareIntegerVector(args[0].asRelationalCondition(), args[1].simdInfo(), args[2].fpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::CompareIntegerVectorWithZero:
switch (this->args.size()) {
case 4:
#if CPU(ARM64)
if (isARM64()) {
jit.compareIntegerVectorWithZero(args[0].asRelationalCondition(), args[1].simdInfo(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 5:
#if CPU(X86_64)
if (isX86_64()) {
jit.compareIntegerVectorWithZero(args[0].asRelationalCondition(), args[1].simdInfo(), args[2].fpr(), args[3].fpr(), args[4].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::VectorUnsignedMax:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorUnsignedMax(args[0].simdInfo(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorUnsignedMin:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorUnsignedMin(args[0].simdInfo(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorAdd:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorAdd(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorSub:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorSub(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorAddSat:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorAddSat(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorSubSat:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorSubSat(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorMul:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorMul(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorMulByElementFloat32:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorMulByElementFloat32(args[0].fpr(), args[1].fpr(), args[2].asTrustedImm32(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorMulByElementFloat64:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorMulByElementFloat64(args[0].fpr(), args[1].fpr(), args[2].asTrustedImm32(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorDiv:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorDiv(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorMin:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorMin(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorMax:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorMax(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorPmin:
switch (this->args.size()) {
case 5:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorPmin(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr(), args[4].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 4:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorPmin(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::VectorPmax:
switch (this->args.size()) {
case 5:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorPmax(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr(), args[4].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 4:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorPmax(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::VectorNarrow:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorNarrow(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr(), args[4].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorBitwiseSelect:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorBitwiseSelect(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorNot:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorNot(args[0].simdInfo(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorAnd:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorAnd(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorAndnot:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorAndnot(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorOr:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorOr(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorXor:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorXor(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::MoveZeroToVector:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.moveZeroToVector(args[0].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorUshl:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorUshl(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorSshr:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorSshr(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorUshr:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorUshr(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorSshl:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorSshl(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorUshl8:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorUshl8(args[0].fpr(), args[1].fpr(), args[2].fpr(), args[3].fpr(), args[4].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorUshr8:
switch (this->args.size()) {
case 5:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorUshr8(args[0].fpr(), args[1].fpr(), args[2].fpr(), args[3].fpr(), args[4].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 4:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorUshr8(args[0].simdInfo(), args[1].fpr(), args[2].asTrustedImm32(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::VectorSshr8:
switch (this->args.size()) {
case 5:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorSshr8(args[0].fpr(), args[1].fpr(), args[2].fpr(), args[3].fpr(), args[4].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 4:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorSshr8(args[0].simdInfo(), args[1].fpr(), args[2].asTrustedImm32(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::VectorHorizontalAdd:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorHorizontalAdd(args[0].simdInfo(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorZipUpper:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorZipUpper(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorUnzipEven:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorUnzipEven(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorExtractPair:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorExtractPair(args[0].simdInfo(), args[1].asTrustedImm32(), args[2].fpr(), args[3].fpr(), args[4].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorAbs:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorAbs(args[0].simdInfo(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorAbsInt64:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorAbsInt64(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorNeg:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorNeg(args[0].simdInfo(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorPopcnt:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorPopcnt(args[0].simdInfo(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorCeil:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorCeil(args[0].simdInfo(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorFloor:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorFloor(args[0].simdInfo(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorTrunc:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorTrunc(args[0].simdInfo(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorTruncSat:
switch (this->args.size()) {
case 3:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorTruncSat(args[0].simdInfo(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 6:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorTruncSat(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].gpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::VectorTruncSatUnsignedFloat32:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorTruncSatUnsignedFloat32(args[0].fpr(), args[1].fpr(), args[2].gpr(), args[3].fpr(), args[4].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorTruncSatSignedFloat64:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorTruncSatSignedFloat64(args[0].fpr(), args[1].fpr(), args[2].gpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorTruncSatUnsignedFloat64:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorTruncSatUnsignedFloat64(args[0].fpr(), args[1].fpr(), args[2].gpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorConvert:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorConvert(args[0].simdInfo(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorConvertUnsigned:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorConvertUnsigned(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorConvertLow:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorConvertLow(args[0].simdInfo(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorConvertLowSignedInt32:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorConvertLowSignedInt32(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorConvertLowUnsignedInt32:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorConvertLowUnsignedInt32(args[0].fpr(), args[1].fpr(), args[2].gpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorNearest:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorNearest(args[0].simdInfo(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorSqrt:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorSqrt(args[0].simdInfo(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorExtendLow:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorExtendLow(args[0].simdInfo(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorExtendHigh:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorExtendHigh(args[0].simdInfo(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorPromote:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorPromote(args[0].simdInfo(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorDemote:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorDemote(args[0].simdInfo(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorLoad8Splat:
switch (this->args.size()) {
case 2:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorLoad8Splat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 3:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorLoad8Splat(args[0].asAddress(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::VectorLoad16Splat:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorLoad16Splat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorLoad32Splat:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorLoad32Splat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorLoad64Splat:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorLoad64Splat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorLoad8Lane:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorLoad8Lane(args[0].asAddress(), args[1].asTrustedImm32(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorLoad16Lane:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorLoad16Lane(args[0].asAddress(), args[1].asTrustedImm32(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorLoad32Lane:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorLoad32Lane(args[0].asAddress(), args[1].asTrustedImm32(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorLoad64Lane:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorLoad64Lane(args[0].asAddress(), args[1].asTrustedImm32(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorStore8Lane:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorStore8Lane(args[0].fpr(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorStore16Lane:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorStore16Lane(args[0].fpr(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorStore32Lane:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorStore32Lane(args[0].fpr(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorStore64Lane:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorStore64Lane(args[0].fpr(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorAnyTrue:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorAnyTrue(args[0].fpr(), args[1].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorAllTrue:
switch (this->args.size()) {
case 4:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorAllTrue(args[0].simdInfo(), args[1].fpr(), args[2].gpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 3:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorAllTrue(args[0].simdInfo(), args[1].fpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::VectorBitmask:
switch (this->args.size()) {
case 3:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorBitmask(args[0].simdInfo(), args[1].fpr(), args[2].gpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 4:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorBitmask(args[0].simdInfo(), args[1].fpr(), args[2].gpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::VectorExtaddPairwise:
switch (this->args.size()) {
case 3:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorExtaddPairwise(args[0].simdInfo(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 5:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorExtaddPairwise(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].gpr(), args[4].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::VectorExtaddPairwiseUnsignedInt16:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorExtaddPairwiseUnsignedInt16(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorAddPairwise:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorAddPairwise(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorAvgRound:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorAvgRound(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorMulHigh:
switch (this->args.size()) {
case 4:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorMulHigh(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 5:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorMulHigh(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr(), args[4].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::VectorMulLow:
switch (this->args.size()) {
case 4:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorMulLow(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 5:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorMulLow(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr(), args[4].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::VectorMulSat:
switch (this->args.size()) {
case 3:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorMulSat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 5:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorMulSat(args[0].fpr(), args[1].fpr(), args[2].fpr(), args[3].gpr(), args[4].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::VectorDotProduct:
switch (this->args.size()) {
case 4:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorDotProduct(args[0].fpr(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case 3:
#if CPU(X86_64)
if (isX86_64()) {
jit.vectorDotProduct(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
default:
break;
}
break;
case Opcode::VectorSwizzle:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorSwizzle(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorSwizzle2:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorSwizzle2(args[0].fpr(), args[1].fpr(), args[2].fpr(), args[3].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorFusedMulAdd:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorFusedMulAdd(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorFusedNegMulAdd:
#if CPU(X86_64) || CPU(ARM64)
if (isX86_64() || isARM64()) {
jit.vectorFusedNegMulAdd(args[0].simdInfo(), args[1].fpr(), args[2].fpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorDupElementInt8:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorDupElementInt8(args[0].asTrustedImm32(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorDupElementInt16:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorDupElementInt16(args[0].asTrustedImm32(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorDupElementInt32:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorDupElementInt32(args[0].asTrustedImm32(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorDupElementInt64:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorDupElementInt64(args[0].asTrustedImm32(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorDupElementFloat32:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorDupElementFloat32(args[0].asTrustedImm32(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::VectorDupElementFloat64:
#if CPU(ARM64)
if (isARM64()) {
jit.vectorDupElementFloat64(args[0].asTrustedImm32(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
}
#endif
break;
break;
case Opcode::Oops:
jit.oops();
OPGEN_RETURN(result);
break;
break;
case Opcode::EntrySwitch:
OPGEN_RETURN(EntrySwitchCustom::generate(*this, jit, context));
break;
case Opcode::Shuffle:
OPGEN_RETURN(ShuffleCustom::generate(*this, jit, context));
break;
case Opcode::Patch:
OPGEN_RETURN(PatchCustom::generate(*this, jit, context));
break;
case Opcode::CCall:
OPGEN_RETURN(CCallCustom::generate(*this, jit, context));
break;
case Opcode::ColdCCall:
OPGEN_RETURN(ColdCCallCustom::generate(*this, jit, context));
break;
case Opcode::WasmBoundsCheck:
OPGEN_RETURN(WasmBoundsCheckCustom::generate(*this, jit, context));
break;
default:
break;
}
RELEASE_ASSERT_NOT_REACHED();
return result;
}
} } } // namespace JSC::B3::Air
#pragma pop_macro("RotateLeft32")
#pragma pop_macro("RotateLeft64")
#pragma pop_macro("RotateRight32")
#pragma pop_macro("RotateRight64")
#pragma pop_macro("StoreFence")
#pragma pop_macro("LoadFence")
#pragma pop_macro("MemoryFence")

#endif // ENABLE(B3_JIT)

WTF_ALLOW_UNSAFE_BUFFER_USAGE_END
